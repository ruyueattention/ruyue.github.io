<!-- build time:Sun Jul 02 2023 10:10:29 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="//gcore.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//gcore.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/favicon.ico"><link rel="mask-icon" href="//gcore.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/logo.svg" color=""><link rel="manifest" href="//gcore.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/manifest.json"><meta name="msapplication-config" content="//gcore.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="如月专注" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="如月专注" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="如月专注" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//gcore.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/2022/10/06/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"><title>Java RMI（远程方法调用）漏洞分析 - Java | 如月专注</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Java RMI（远程方法调用）漏洞分析</h1><div class="meta"><span class="item" title="创建时间：2022-10-06 16:08:21"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-10-06T16:08:21+08:00">2022-10-06</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>6.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>6 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">如月专注</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/36.png"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/小夫2.png"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/小夫4.png"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/小夫1.png"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/3.jpg"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/2.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//gcore.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/avatar.jpg"><meta itemprop="name" content="ruyue"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="如月专注"></span><div class="body md" itemprop="articleBody"><h1 id="简介"><a class="anchor" href="#简介">#</a> 简介</h1><p>PS：这里主要是我对 RMI 流程的跟踪，还有一些理解吧。这玩意越学越烦，艹。这篇文章不涉及漏洞利用，想略过原理直接看利用的看下一篇。</p><p>RMI (Remote Method Invocation) 即 Java 远程方法调用，RMI 用于构建分布式应用程序，类似于 RPC（Remote Procedure Call Protocol) 远程过程调用协议，RMI 实现了 Java 程序之间跨 JVM 的远程通信，使得一个 JMV 上的对象可以调用另一个 JMV 上的方法（方法在远程 JVM 上执行，只是返回运行结果）。这两个 JVM 可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。</p><p>PS：RPC 可以理解成是一种思想，而 RMI 是这种思想在 java 中的体现，jrmp 就是 rmi 的具体实现协议。</p><h2 id="参考链接"><a class="anchor" href="#参考链接">#</a> 参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYxMDY3My9hcnRpY2xlL2RldGFpbHMvMTI0MTM4NTM3">https://blog.csdn.net/weixin_43610673/article/details/124138537</span></p><p>（必看）b 站搜 白日梦组长</p><h1 id="简单使用"><a class="anchor" href="#简单使用">#</a> 简单使用</h1><p>RMI 最终实现的目的还是远程方法调用，也就是说我们可以调用远程对象的方法。</p><p>所以我们这里可以做一个场景：远程调用目标服务器上的一个对象的指定方法。</p><p>这里我们具体的测试方案就是 服务端存在一个 User 类，这个 User 类存在两个方法，一个用来为 User 这个对象赋值，一个是对 username 这个成员变量进行大写转换。</p><p>我们要实现的目标就是客户端远程调用这个 User 类的这两个方法。</p><p><strong>①因为最终目标客户端上需要获取服务端的某个对象，并且客户端要能够操作这个对象的某些方法。所以客户端和服务段上都应该要有一个同样的接口。但客户端并不需要对这个接口进行实现。</strong></p><p><strong>②客户端和服务端的接口需要在相同的包名才能正常序列化和反序列化。（PS: 传输的对象其实是需要实现序列化接口的，但因为我们继承的那个 UnicastRemoteObject 类已经实现了序列化接口，所以我们是不需要特别设置了）</strong></p><h2 id="server"><a class="anchor" href="#server">#</a> Server</h2><h3 id="创建接口"><a class="anchor" href="#创建接口">#</a> 创建接口</h3><p>首先，我们针对 User 这个类做一个接口，然后里面定义上这个接口存在的方法。</p><p><strong>服务段接口处必须继承 Remote 类，并且里面的方法需要抛出 RemoteException。</strong></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020145219979.png" alt="image-20221020145219979"></p><h3 id="实现接口"><a class="anchor" href="#实现接口">#</a> 实现接口</h3><p>接着就需要对这个接口进行一个实现了，只有实现了才能当作对象来传输给客户端。</p><p><strong>要传输给客户端的实现类必须继承 UnicastRemoteObject 类（不继承也行，得在构造函数调用这个类的 exportObject 方法）</strong></p><p>如下图，我们这个 UserImpl 类就实现了这个接口，完成了两个方法的填充。接着服务端就做完了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020145245849.png" alt="image-20221020145245849"></p><h2 id="注册中心"><a class="anchor" href="#注册中心">#</a> 注册中心</h2><p>前面其实就已经完成了 Server 的搭建，我们的实现类就是一个服务端（只是还没创建起来）<br>接着只需要把注册中心给搭建起来，这边就完成了。</p><p>PS：其实注册中心和 Server 基本都在一块的，这里当我们创建一个对象实例时，其实服务器已经开始监听一个随机的高位端口了，也就是说服务端已经跑起来了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020145444639.png" alt="image-20221020145444639"></p><h2 id="client"><a class="anchor" href="#client">#</a> Client</h2><p>前面我们讲了，在客户端中也要有这个类的一个接口（没有接口的话，编译器不知道获取的对象有什么方法，而且调用远程对象时 methodhash 会错误）。并且我们需要保证<strong>客户端和服务端的接口需要在相同的包名下。</strong></p><p>如图：客户端只需简单的创建一个接口就行，里面的实现不用管。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020145508459.png" alt="image-20221020145508459"></p><p>接着我们尝试去进行远程方法调用了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020145544504.png" alt="image-20221020145544504"></p><p>最终输出结果：</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020145551955.png" alt="image-20221020145551955"></p><h1 id="简单分析下"><a class="anchor" href="#简单分析下">#</a> 简单分析下</h1><p>这里简单的说下我的理解：</p><p>服务端就是提供远程服务的，它本质上就是一个类，一个对象，也就是说一个对象就是一个服务端。当一个继承了 UnicastRemoteObject 类的类被实例化成对象时，这个对象就变成了一个服务端，并且这个对象会被发布到本地的一个网络端口上，对外提供服务。</p><p>而注册中心就是管理这些服务端的，比如说你创建了 10 个对象，那这些对象都是单独的服务端，都有一个随机的高位端口。这种时候客户端想调用就很麻烦，而注册中心就是把这些服务端的网络位置信息给放到一个 hashMap 中存起来，这样客户端只需和注册中心交互，就能知道对应的服务端在哪里了。</p><p>客户端，没什么好解释的。客户端先是从注册中心拿到它想要的远程对象（服务端）的网络信息，然后再和这个对象（服务端）进行连接获取资源，操作对象。</p><p>结合下面两张图食用。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020145654270.png" alt="image-20221020145654270"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020145702182.png" alt="image-20221020145702182"></p><h1 id="深入分析流程"><a class="anchor" href="#深入分析流程">#</a> 深入分析流程</h1><p>如果只是了解 RMI 是什么，怎么利用和绕过的话，这里就没必要学了。这部分主要是介绍 RMI 的各个部分在干什么，为什么会导致反序列化漏洞而已。而且巨难理解，我反正没吃透。</p><p>这里就分析了服务端和注册中心，客户端是没分析的，主要是流程差不多，懒得追了。</p><h2 id="server的创建深入分析"><a class="anchor" href="#server的创建深入分析">#</a> Server 的创建深入分析</h2><p>PS: 对 Server 和 registry 分析的时候我也有点云里雾里，没太懂，就大致搞清楚了流程而已，问题不大。</p><p>这里我们的目的是去分析 server 是怎么包装对象和发布的。</p><p>因为 rmi 这个模块是在 sun 包中的，sun 包是没源码的，所以在分析前，先把 sun 包的源码给引入到 SDK 中，不然调试不过去。具体操作就不多说了，看 B 站白日梦组长讲 CC 链的那个视频，他有讲怎么做。</p><h3 id="入口"><a class="anchor" href="#入口">#</a> 入口</h3><p>这里我们注释掉注册中心的代码，给服务端打上断点，进行跟踪分析。</p><p>因为这个 UserImpl 继承了 UnicastRemoteObject 类，并且 UserImpl 的构造方法没任何内容，所以它会隐式调用父类的构造方法。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150041215.png" alt="image-20221020150041215"></p><h3 id="当前是unicastremoteobject类"><a class="anchor" href="#当前是unicastremoteobject类">#</a> 当前是 UnicastRemoteObject 类</h3><p>ok，跟着走，因为我们这个类它是继承了 UnicastRemoteObject 这个类的，所以会调用它的构造方法。进而走到这个 exportObject 方法。这个方法简单理解为暴露对象。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150052432.png" alt="image-20221020150052432"></p><p>继续跟进发现又调用了 exportObject，但此时给的参数不同了，也就是说调用的方法是另一个，见下图，此时看不太懂这个 exportObject 做了什么，先不管，先按照执行流程走。</p><p>这里我们简单看一下，这个 new UnicastServerRef 做了什么，可以看到它的参数是一个 port，所以可以大胆猜测这个类就是做网络请求的。</p><p>因此这个 exportObject 的功能我们也可以大胆猜测：就是把对象和网络关联起来，也就是把这个对象绑定到某个端口上，以便后续调用。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150108772.png" alt="image-20221020150108772"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150113810.png" alt="image-20221020150113810"></p><h3 id="此时换到了unicastserverref类"><a class="anchor" href="#此时换到了unicastserverref类">#</a> 此时换到了 UnicastServerRef 类</h3><p>接着我们分析下前面猜测的那个处理网络请求的 UnicastServerRef 类。</p><p>跟进去发现，它调用了父类的构造方法，传参是一个叫 liveRef 的类，这个类的参数还是一个端口。此时感觉这个 UnicastServerRef 其实还是没什么用，就单纯的套娃，简单看了下构造器，发现确实是真的没什么用，就是把 liveRef 赋值给另一个参数而已。真正处理网络逻辑的应该是 LiveRef (port).</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150127230.png" alt="image-20221020150127230"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150130195.png" alt="image-20221020150130195"></p><h3 id="又换到了另一个类-liveref类"><a class="anchor" href="#又换到了另一个类-liveref类">#</a> 又换到了另一个类 - LiveRef 类</h3><p>跟进 LiveRef，我套它个猴子，又开始套娃了。这个 ObjID 简单看了下没什么用就生成一个随机 ID 的。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150143686.png" alt="image-20221020150143686"></p><p>此时跟进它的两参构造器，发现又又又套娃，老样子，先看看它的构造器，发现也没操作什么对象，和前面一样就是对一些值进行了赋予而已。所以真正处理网络的是 TCPEndpoint.getLocalEndpoint (port) 这个对象。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150154765.png" alt="image-20221020150154765"></p><h3 id="此时跳到了tcpendpoint类"><a class="anchor" href="#此时跳到了tcpendpoint类">#</a> 此时跳到了 TCPEndpoint 类</h3><p>跟进这个对象，发现它又在调自己，不管他，往下看，发现它获取了 ip，获取了本机的 ip。但很可惜，这个方法走完都没看到端口在变的。只是拿到了 ip 而已。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150210580.png" alt="image-20221020150210580"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150216069.png" alt="image-20221020150216069"></p><p>到这里就没有更深入的其他调用了，就是慢慢的解套，一直跟，最后回到我们前面没分析明白的 exportObject (Remote obj, UnicastServerRef sref) 这个两参构造器了。</p><h3 id="此时回到了unicastremoteobject这个类"><a class="anchor" href="#此时回到了unicastremoteobject这个类">#</a> 此时回到了 UnicastRemoteObject 这个类</h3><p>这里回到了我们前面 UnicastRemoteObject 这个类的两参 expoetObject 方法。</p><p>但这个方法中间也只是做了一些赋值的操作。</p><p>但在最后 return 时，我们发现它又又又调用了一个类的 exportObject 方法（当前是 UnicastRemoteObject 类，这里是跳到了 UnicastRemoteRef 类）。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150237616.png" alt="image-20221020150237616"></p><h3 id="来到另一个没去过的类unicastremoteref类"><a class="anchor" href="#来到另一个没去过的类unicastremoteref类">#</a> 来到另一个没去过的类 UnicastRemoteRef 类</h3><p>ok，继续跟进。此时来到 UnicastRemoteRef 类的三参 exportObject 方法。这里我跳快了，不知道什么情况，它就拿到了端口。而且这里我们发现，它 return 了一个叫 stub 的玩意，这个玩意不就是给客户端的东西么。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150303916.png" alt="image-20221020150303916"></p><p>重新打上断点，重新调试一次，看看这个端口在哪偷偷摸摸拿到的。最后发现是在 LiveRef 的 exportObject 上拿到的。这里需要注意的是它传了一个 target 进去，这个 target 由很多东西组成，我们后续再分析。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150316681.png" alt="image-20221020150316681"></p><h3 id="追踪回到liveref类和tcpendpoint类最后到tcptransport类"><a class="anchor" href="#追踪回到liveref类和tcpendpoint类最后到tcptransport类">#</a> 追踪回到 LiveRef 类和 TCPEndpoint 类最后到 TCPTransport 类</h3><p>又跳到 TCPEndpoint 类的 exportObject</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150334073.png" alt="image-20221020150334073"></p><p>最后是跟进到了 TCPTransport 类中，发现它是最后一步了，这里直接开始监听端口。到这里网络层的东西我们就搞清楚了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150343657.png" alt="image-20221020150343657"></p><p>可以看到，这里是开启了一个 socket 端口，然后后面是开启了线程等待客户端的连接。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150351713.png" alt="image-20221020150351713"></p><p>跟进这个 newServerSocket，就能看到它的端口是怎么获取的了，再往下就没必要分析了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150400094.png" alt="image-20221020150400094"></p><p>但别忘记，前面我们还传入了 target 这个东西，target 由很多东西组成，我们也简单分析看下它到底做了什么（主要是感觉我也不太懂这个 target 到底做了什么，能看懂的就是被塞到了两个表里）。</p><p>这里跟踪过程略过。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150407939.png" alt="image-20221020150407939"></p><p>最后确实塞到了两个静态表里，应该是用来对应网络发布的，就前面那个 socket 网络端口对应的数据是这个 target。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150417009.png" alt="image-20221020150417009"></p><h3 id="unicastserverref类-stub存根成分分析"><a class="anchor" href="#unicastserverref类-stub存根成分分析">#</a> UnicastServerRef 类 - Stub（存根）成分分析</h3><p>接着我们回过头来分析 Stub 的成分。看这个函数，感觉 stub 就是一个代理对象。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150430548.png" alt="image-20221020150430548"></p><p>跟进去到 Util 类，很明显的动态代理创建，然后接口是 User 接口。也就是说客户端拿到的也是个代理对象，然后通过代理对象再操作返回结果给客户端。</p><p>而且这里的 handler 可以看到就是一些网络处理的类，所以这个代理的意义就是不言而喻了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150439145.png" alt="image-20221020150439145"></p><p>而且在这段代码中，不只是创建了存根，骨架也一并创建了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150446227.png" alt="image-20221020150446227"></p><h3 id="小结"><a class="anchor" href="#小结">#</a> 小结</h3><p>到这里，差不多就搞完了 Server 的分析，虽然仍有疑问，但大致流程还是能够梳理出来的，Server 先是</p><p>通过一系列手段占用一个高位端口，进行监听，然后把这个端口的信息 LiveRef 绑定到 User 类的代理类 Stub 上。</p><p>最后得到的对象就是一个含 LiveRef 信息的 User 实例（其实就是存根）。</p><p>其中存根 Stub 是建立 socket 连接，并向 Skeleton 发请求的。通过 Skeleton 调用 User 这个类的相应的方法，最后接收返回的结果。</p><p>而骨架 Skeleton 类用到了线程，它长驻在后台运行，随时接收 client 发过来的 request。并根据发送过来的 key 去调用相应的对象的 method。</p><h2 id="registrt的创建分析"><a class="anchor" href="#registrt的创建分析">#</a> Registrt 的创建分析</h2><p>接着我们来看注册中心它到底做了什么呢？</p><p>从代码来看它就两行很短，简单的看就是开启监听器了一个端口，然后用字典把存根给存了起来。对外提供服务。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150527302.png" alt="image-20221020150527302"></p><h3 id="registry对象的创建"><a class="anchor" href="#registry对象的创建">#</a> Registry 对象的创建</h3><p>跟进代码发现，没能步入 try，进入到的是 else 语句，这里就两行代码，第一行我们老懂了，就是和 server 一样，创建一个网络端口而已，返回的是这个网络引用的信息。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150542942.png" alt="image-20221020150542942"></p><p>然后我们分析第二个代码，先不管 setup 方法，看 UnicastServerRef 这个类，它很明显就是把注册中心这个对象给绑定到了我们生成的 LiveRef 类中，也就是说把注册中心这个对象给绑定成了远程对象，让它能够被远程访问调用。</p><p>然后再看 setup 方法。一个 ref.exportObject，就是把这个远程对象给发布出去了。简单跟进去一看，其实就是和 Server 中的差不多，创建存根什么什么的。也就是说客户端和注册中心访问也是依赖存根的 emm。毕竟这个存根存储了注册中心这个对象和它的网络引用。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150557484.png" alt="image-20221020150557484"></p><h3 id="绑定远程对象"><a class="anchor" href="#绑定远程对象">#</a> 绑定远程对象</h3><p>这个 bind 就一个函数，没什么奇奇怪怪的调用，进来就是先判断 bindings 这个 hash 表是否有重名的 key 了，有就抛出错误，否则就把我们的远程对象给绑定到 hash 表中，提供服务。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150610967.png" alt="image-20221020150610967"></p><p>可以看到这个 registry 对象，它有两个内容，一个就是 bindings 这个 hash 表，另一个就是 ref，它自己的存根。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020150622621.png" alt="image-20221020150622621"></p><h3 id="小结-2"><a class="anchor" href="#小结-2">#</a> 小结</h3><p>简单来看，这个 Registry 对象的创建其实是和 Server 创建远程对象一样的，只是这里绑定的是固定端口罢了。并且这个对象还用一个 hash 表去存储了服务对象提供的对象的存根。没什么难度 ok。</p><h1 id="各个角色受到的威胁"><a class="anchor" href="#各个角色受到的威胁">#</a> 各个角色受到的威胁</h1><p>在 rmi 中所有在网络上传输的数据都是序列化数据。服务端、注册中心、客户端都会受到其他两者的威胁。也就是说 RMI 在涉及之初就没考虑过安全。所有角色都会受到其他两者的威胁。</p><p>以下我们还是以分析流程来找有问题的点。只做分析，具体攻击利用看下篇。</p><h2 id="客户端受到的威胁"><a class="anchor" href="#客户端受到的威胁">#</a> 客户端受到的威胁</h2><h3 id="来自注册中心的威胁"><a class="anchor" href="#来自注册中心的威胁">#</a> 来自注册中心的威胁</h3><h4 id="创建本地注册中心对象"><a class="anchor" href="#创建本地注册中心对象">#</a> 创建本地注册中心对象</h4><p>这里并没有去真正连接目标注册中心，只是在本地又创建了一个注册中心的 stub 对象，跟进代码，代码量不大，没什么套娃，而且调用的方法都是我们之前常调用的那几个。无非就是创建 LiveRef，然后绑定到 stub 中，返回而已。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151120900.png" alt="image-20221020151120900"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151129447.png" alt="image-20221020151129447"></p><h4 id="调用lookup真正连接注册中心获取远程对象stub"><a class="anchor" href="#调用lookup真正连接注册中心获取远程对象stub">#</a> 调用 lookup 真正连接注册中心获取远程对象 stub</h4><p>这里代码也不是很复杂，很明显了，客户端和服务端的数据传输是通过 socket 来完成的并且在传输过程中对象都是经过了序列化和反序列化的，这就意味着如果注册中心是恶意的，我们的客户端就有可能受到威胁。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151147051.png" alt="image-20221020151147051"></p><p>当然前面只是其中一个反序列化点，其实还存在另一个点，就是 ref.invoke（call）这个，我们可以尝试跟进去，</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151158153.png" alt="image-20221020151158153"></p><p>跟进来只后，跳到了 UnicastRef 这个类的 invoke，可以看到它调用了 call 的 executeCall 方法。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151205022.png" alt="image-20221020151205022"></p><p>我们继续追踪，来到了 StreamRemoteCall 类的 executeCall 方法。可以看到，这里存在着一个处理异常的代码出现了 readObject 操作。这里代码设置本意可能是如果输入流是个异常类，它就可以通过反序列化来获取得更多详细信息。这就导致如果注册中心返回一个恶意的流的话，客户端就会在这里进行反序列化。而几乎每个涉及连接注册中心的方法都会用这个 invoke。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151212607.png" alt="image-20221020151212607"></p><h3 id="来自服务端的威胁"><a class="anchor" href="#来自服务端的威胁">#</a> 来自服务端的威胁</h3><p>接着我们来分析客户端请求服务段的流程了，首先，进入到的是 RemoteObjectInvocationHandler 这个处理器的 invoke 方法（理所当然的，调用代理对象的任意方法都会进入处理器的 hander 方法）。</p><p>然后追着追着，它就跳到了 UnicastRef 的 invoke 方法了，在这里就很关键了。（那个 marshaValue 方法是先判断参数是否为基础类型，不是就序列化）</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151313525.png" alt="image-20221020151313525"></p><p>这里还是这个 invoke 方法，可以看到，我们就算没那个 call.execuetCall 来执行反序列化，在下面的地方他一样亲自进行了反序列化。从这里我们也可以看出，这个处理器的存在就导致着，客户端在 RMI 中，时时刻刻都有可能受到注册中心和服务段的反序列漏洞攻击。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151323561.png" alt="image-20221020151323561"></p><h2 id="注册中心受到的威胁"><a class="anchor" href="#注册中心受到的威胁">#</a> 注册中心受到的威胁</h2><p>因为注册中心和服务端在高版本 JDK 下，只能在同一台机子，所以这里就不讨论注册中心和服务端之间的互相威胁了，只讨论客户端是怎么威胁注册中心和服务端的。</p><p>首先客户端和注册中心的交互主要有连接注册中心和获取注册中心中注册的 stub。</p><p>从上面的交互图中，我们得知，客户端操作的是 stub 来访问我们的骨架 skel，所以在注册中心，我们的断点也是下在 stub 那边。也就是 RegistrImpl_Skel 中（对应的路径是 rt.jar/sun/rmi/registry/RegistryImpl_Skel）。</p><p>这里我们进去之间就发现 dispatch 这个方法很有可能是处理客户端调用逻辑的。先简单分析，可以看到下面有个 switch 选择，其中分了很多 case，并且不同 case 还给了注释，这下子我们就很清晰了，不同的 case 对应的是不同的方法调用。但多个 case 里面都涉及到了 readObject 的调用，所以就很明显存在反序列化了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151355527.png" alt="image-20221020151355527"></p><p>接着我们下断点来分析哈，可以看到，客户端传进来的 String 类型 user 就是它的参数，如果此次传的是恶意对象就有可能威胁到注册中心。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151409032.png" alt="image-20221020151409032"></p><h2 id="服务端受到的威胁"><a class="anchor" href="#服务端受到的威胁">#</a> 服务端受到的威胁</h2><p>这里我们继续分析客户端在调用远程方法时，服务端是怎么去处理的。</p><p>这里断点应该在哪呢？老样子，一般都是 Dispatcher 这个调度器来操作的。所以先找这个类。这里在 sun.rmi.server 目录下只找到了它的接口，那就继续寻找这个接口的实现，发现 UnicastServerRef 这个类比较像是处理数据的类。追踪里面的 dispatcher 方法。打上几个断点看看传进来的是什么东西。</p><p>可以看到，这里 parms 参数就是客户端搞过来的传参，然后后面就是对这个参数进行反序列化了。并且它上面的注释也写的很明显了，反序列化参数。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151430113.png" alt="image-20221020151430113"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151434820.png" alt="image-20221020151434820"></p><p>同样的，下边的代码处，也是对返回结果进行了序列化给客户端的，所以说客户端也是会受到服务端的威胁的。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221020151443110.png" alt="image-20221020151443110"></p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-11-09 15:39:36" itemprop="dateModified" datetime="2022-11-09T15:39:36+08:00">2022-11-09</time> </span><span id="2022/10/06/Java RMI（远程方法调用）漏洞分析/" class="item leancloud_visitors" data-flag-title="Java RMI（远程方法调用）漏洞分析" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>ruyue <i class="ic i-at"><em>@</em></i>如月专注</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2022/10/06/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="Java RMI（远程方法调用）漏洞分析">http://example.com/2022/10/06/Java RMI（远程方法调用）漏洞分析/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/09/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(4)-CC1/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;ruyue-1258558004.cos.ap-guangzhou.myqcloud.com&#x2F;note&#x2F;小夫6.png" title="Java反序列化(4)-CC1"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>Java反序列化(4)-CC1</h3></a></div><div class="item right"><a href="/2022/11/09/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;ruyue-1258558004.cos.ap-guangzhou.myqcloud.com&#x2F;note&#x2F;小夫6.png" title="Java RMI（远程方法调用）漏洞利用"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>Java RMI（远程方法调用）漏洞利用</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#server"><span class="toc-number">2.1.</span> <span class="toc-text">Server</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.1.</span> <span class="toc-text">创建接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.2.</span> <span class="toc-text">实现接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">2.2.</span> <span class="toc-text">注册中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#client"><span class="toc-number">2.3.</span> <span class="toc-text">Client</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E4%B8%8B"><span class="toc-number">3.</span> <span class="toc-text">简单分析下</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">深入分析流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#server%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">Server 的创建深入分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3"><span class="toc-number">4.1.1.</span> <span class="toc-text">入口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E6%98%AFunicastremoteobject%E7%B1%BB"><span class="toc-number">4.1.2.</span> <span class="toc-text">当前是 UnicastRemoteObject 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A4%E6%97%B6%E6%8D%A2%E5%88%B0%E4%BA%86unicastserverref%E7%B1%BB"><span class="toc-number">4.1.3.</span> <span class="toc-text">此时换到了 UnicastServerRef 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%88%E6%8D%A2%E5%88%B0%E4%BA%86%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB-liveref%E7%B1%BB"><span class="toc-number">4.1.4.</span> <span class="toc-text">又换到了另一个类 - LiveRef 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A4%E6%97%B6%E8%B7%B3%E5%88%B0%E4%BA%86tcpendpoint%E7%B1%BB"><span class="toc-number">4.1.5.</span> <span class="toc-text">此时跳到了 TCPEndpoint 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A4%E6%97%B6%E5%9B%9E%E5%88%B0%E4%BA%86unicastremoteobject%E8%BF%99%E4%B8%AA%E7%B1%BB"><span class="toc-number">4.1.6.</span> <span class="toc-text">此时回到了 UnicastRemoteObject 这个类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A5%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%B2%A1%E5%8E%BB%E8%BF%87%E7%9A%84%E7%B1%BBunicastremoteref%E7%B1%BB"><span class="toc-number">4.1.7.</span> <span class="toc-text">来到另一个没去过的类 UnicastRemoteRef 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E8%B8%AA%E5%9B%9E%E5%88%B0liveref%E7%B1%BB%E5%92%8Ctcpendpoint%E7%B1%BB%E6%9C%80%E5%90%8E%E5%88%B0tcptransport%E7%B1%BB"><span class="toc-number">4.1.8.</span> <span class="toc-text">追踪回到 LiveRef 类和 TCPEndpoint 类最后到 TCPTransport 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unicastserverref%E7%B1%BB-stub%E5%AD%98%E6%A0%B9%E6%88%90%E5%88%86%E5%88%86%E6%9E%90"><span class="toc-number">4.1.9.</span> <span class="toc-text">UnicastServerRef 类 - Stub（存根）成分分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.1.10.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#registrt%E7%9A%84%E5%88%9B%E5%BB%BA%E5%88%86%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">Registrt 的创建分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#registry%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.2.1.</span> <span class="toc-text">Registry 对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.2.</span> <span class="toc-text">绑定远程对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">4.2.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E8%A7%92%E8%89%B2%E5%8F%97%E5%88%B0%E7%9A%84%E5%A8%81%E8%83%81"><span class="toc-number">5.</span> <span class="toc-text">各个角色受到的威胁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%97%E5%88%B0%E7%9A%84%E5%A8%81%E8%83%81"><span class="toc-number">5.1.</span> <span class="toc-text">客户端受到的威胁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A5%E8%87%AA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%A8%81%E8%83%81"><span class="toc-number">5.1.1.</span> <span class="toc-text">来自注册中心的威胁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">创建本地注册中心对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8lookup%E7%9C%9F%E6%AD%A3%E8%BF%9E%E6%8E%A5%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%8E%B7%E5%8F%96%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1stub"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">调用 lookup 真正连接注册中心获取远程对象 stub</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A5%E8%87%AA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%A8%81%E8%83%81"><span class="toc-number">5.1.2.</span> <span class="toc-text">来自服务端的威胁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8F%97%E5%88%B0%E7%9A%84%E5%A8%81%E8%83%81"><span class="toc-number">5.2.</span> <span class="toc-text">注册中心受到的威胁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%97%E5%88%B0%E7%9A%84%E5%A8%81%E8%83%81"><span class="toc-number">5.3.</span> <span class="toc-text">服务端受到的威胁</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/07/30/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(1)-%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/" rel="bookmark" title="Java反序列化(1)-反射基础">Java反序列化(1)-反射基础</a></li><li><a href="/2022/08/15/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(2)-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/" rel="bookmark" title="Java反序列化(2)-反序列化基础">Java反序列化(2)-反序列化基础</a></li><li><a href="/2022/09/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(3)-URLDNS%E9%93%BE/" rel="bookmark" title="Java反序列化(3)-URLDNS链">Java反序列化(3)-URLDNS链</a></li><li><a href="/2022/09/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(4)-CC1/" rel="bookmark" title="Java反序列化(4)-CC1">Java反序列化(4)-CC1</a></li><li class="active"><a href="/2022/10/06/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="bookmark" title="Java RMI（远程方法调用）漏洞分析">Java RMI（远程方法调用）漏洞分析</a></li><li><a href="/2022/11/09/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" rel="bookmark" title="Java RMI（远程方法调用）漏洞利用">Java RMI（远程方法调用）漏洞利用</a></li><li><a href="/2022/11/15/Java%E5%86%85%E5%AD%98%E9%A9%AC1-Servlet-api%E5%86%85%E5%AD%98%E9%A9%AC/" rel="bookmark" title="Java内存马1:servlet-api类型内存马">Java内存马1:servlet-api类型内存马</a></li><li><a href="/2022/11/29/Java%E5%86%85%E5%AD%98%E9%A9%AC1.5-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B3%A8%E5%85%A5%E5%86%85%E5%AD%98%E9%A9%AC/" rel="bookmark" title="Java内存马1.5:反序列化注入内存马">Java内存马1.5:反序列化注入内存马</a></li><li><a href="/2023/07/02/Java%E5%86%85%E5%AD%98%E9%A9%AC3-%E5%86%85%E5%AD%98%E9%A9%AC%E6%9F%A5%E6%9D%80/" rel="bookmark" title="Java内存马3:内存马查杀">Java内存马3:内存马查杀</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="ruyue" data-src="//gcore.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/avatar.jpg"><p class="name" itemprop="name">ruyue</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">38</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1eXVlYXR0ZW50aW9u" title="https:&#x2F;&#x2F;github.com&#x2F;ruyueattention"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/09/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(4)-CC1/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/09/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Windows%E5%AE%89%E5%85%A8/" title="分类于 Windows安全">Windows安全</a></div><span><a href="/2021/12/26/COM%E5%8A%AB%E6%8C%81/" title="COM在权限维持中的应用">COM在权限维持中的应用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/" title="分类于 服务器配置">服务器配置</a></div><span><a href="/2023/02/20/%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%90%AD%E5%BB%BA/" title="透明代理">透明代理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7/" title="分类于 工具">工具</a></div><span><a href="/2022/03/17/%E8%87%AA%E5%86%99%E5%B7%A5%E5%85%B7PupilSearch/" title="自写工具-PupilSearch">自写工具-PupilSearch</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="分类于 漏洞复现">漏洞复现</a></div><span><a href="/2021/07/21/CVE-2021-1675/" title="CVE-2021-1675(Windows Print Spooler权限提升漏洞)">CVE-2021-1675(Windows Print Spooler权限提升漏洞)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Java/" title="分类于 Java">Java</a></div><span><a href="/2022/11/29/Java%E5%86%85%E5%AD%98%E9%A9%AC1.5-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B3%A8%E5%85%A5%E5%86%85%E5%AD%98%E9%A9%AC/" title="Java内存马1.5:反序列化注入内存马">Java内存马1.5:反序列化注入内存马</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" title="分类于 密码学">密码学</a></div><span><a href="/2022/03/29/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-HTTPS%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" title="HTTPS协议分析">HTTPS协议分析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" title="分类于 密码学">密码学</a></div><span><a href="/2022/03/28/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81RSA%E5%8E%9F%E7%90%86/" title="非对称密码-RSA原理">非对称密码-RSA原理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" title="分类于 密码学">密码学</a></div><span><a href="/2022/03/28/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-SSL%E8%AF%81%E4%B9%A6/" title="非对称密码-SSL证书">非对称密码-SSL证书</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Windows%E5%AE%89%E5%85%A8/" title="分类于 Windows安全">Windows安全</a></div><span><a href="/2021/07/26/Windows%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/" title="Windows远程执行命令">Windows远程执行命令</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/" title="分类于 容器安全">容器安全</a></div><span><a href="/2022/02/15/k8s-kunbernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="k8s-Kubernetes环境搭建">k8s-Kubernetes环境搭建</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">ruyue @ 如月专注</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">162k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">2:27</span></div><div class="powered-by"></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/06/Java RMI（远程方法调用）漏洞分析/",favicon:{show:"夺去目光的故事",hide:"蒙上双眼的故事"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//gcore.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//gcore.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->