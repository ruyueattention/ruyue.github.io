<!-- build time:Thu Feb 09 2023 10:42:58 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/favicon.ico"><link rel="mask-icon" href="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/logo.svg" color=""><link rel="manifest" href="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/manifest.json"><meta name="msapplication-config" content="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="如月专注" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="如月专注" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="如月专注" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/2022/09/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(4)-CC1/"><title>Java反序列化(4)-CC1 - Java | 如月专注</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Java反序列化(4)-CC1</h1><div class="meta"><span class="item" title="创建时间：2022-09-16 10:11:21"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-09-16T10:11:21+08:00">2022-09-16</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.4k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">如月专注</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/小夫1.png"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/小夫4.png"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/小夫6.png"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/小夫3.png"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/2.png"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/5.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/09/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(4)-CC1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/avatar.jpg"><meta itemprop="name" content="ruyue"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="如月专注"></span><div class="body md" itemprop="articleBody"><h1 id="简介"><a class="anchor" href="#简介">#</a> 简介</h1><p>Apache Commons Collections 是对 java.util.Collection 的扩展。它增强了 Java 集合框架。 它提供了几个功能来简化收集处理。 它提供了许多新的接口，实现和实用程序。</p><p>当我们学习了 URL DNS 链后，我们就大致直到反序列化漏洞是怎么威胁服务器的。我们就可以着手分析 CC 链来增加我们对反序列化漏洞的认识了。</p><p>这里我还是跟着 b 站：白日梦组长大佬学习的，环境的搭建可以去 b 站搜他的视频。</p><p>然后呢 CC1 其实有两条利用链，其实大差不差。一条利用了 TransformerMap，一条利用了 LazyMap。</p><h1 id="transformermap这条链的分析"><a class="anchor" href="#transformermap这条链的分析">#</a> TransformerMap 这条链的分析</h1><p>下面的分析我们还是从发掘漏洞的视角走。首先嘛，我们是需要找到一个可能存在危险方法的地方，并且这个地方是我们能够利用的。那就是从危险函数开始找。想直接找到 exec 又不太现实，但我们可以找反射啊，如果哪里有反射的执行，那我们就有机会利用这个反射来执行命令。然后再向上找，直到找到 readObject。</p><h2 id="invokertransformer类分析"><a class="anchor" href="#invokertransformer类分析">#</a> InvokerTransformer 类分析</h2><p>首先，针对 CommonsCollections 这个组件，我们可以看到它有很多接口，其中 Transformer 这个接口，我们追踪其实现类。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153021558.png" alt="image-20220918153021558"></p><p>我们可以看到，这个实现类中的 transform 方法，它居然调用了反射去执行了一些操作。而这里我们经过分析，这个反射中的所有输入我们的可以控制。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153032751.png" alt="image-20220918153032751"></p><p>从这里我们可以看到，这个实现类的构造函数接收 3 个参数，第一个就是要执行的方法的名，数据类型只是简单的 String，第二个则是这个方法的参数的数据类型，要求的参数是一个 Class 数组，第三个则是这个方法的参数具体值，为一个对象数组。这里这个函数用数组的原因就是不确定这个方法有多少个参数，所以它用数组来存储，很正常。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153045354.png" alt="image-20220918153045354"></p><p>接着我们来试试，利用这个 InvokerTransformer 来调用 runtime 实现 RCE。首先我们回忆下，利用反射怎么执行命令。如下，我们简单的利用反射去实现了 RCE。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153054303.png" alt="image-20220918153054303"></p><p>因此如果我们要通过这个类去执行 runtime 这个类的 exec 方法的话，第一个参数 methodName 就是 exec，第二个参数就是这个方法的传参的数据类型的一个数组，第三个则是给这个方法的参数的一个数组。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153103096.png" alt="image-20220918153103096"></p><p>然后上面就绑定好了 Class 反射对象，接着需要给一个具体的对象让他执行，而这个对象的传入就是在 transform 方法中。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153111279.png" alt="image-20220918153111279"></p><p>到这里其实就差不多了，我们只需要把参数拼装给 InvokerTransformer 这个类就可以了。就针对这个类，给它补充它要的参数，然后执行它的危险方法即可。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153118625.png" alt="image-20220918153118625"></p><p><strong>到这里我们差不多就分析完这个 InvokerTransformer 类的作用了。但为了方便理解，我们还是需要做个总结。</strong></p><p><strong>这个类的 transform 方法的作用其实就是用反射的方式帮我们执行我们输入的类对象的某个方法。</strong></p><p><strong>用一个比喻来说就是起到一个修饰的作用，实例化 InvokerTransformer 类就相当于创建了一个装饰器，当调用 transform 方法的时候才对 transform 的参数对象执行装饰这个动作。</strong></p><h2 id="寻找利用链-1transformermap分析"><a class="anchor" href="#寻找利用链-1transformermap分析">#</a> 寻找利用链 - ①TransformerMap 分析</h2><p><strong>PS：这里其实就是找调用了 transform 方法的类。</strong></p><p><strong>因为利用链的最后一步是 InvokerTransformer.transform，所以我们还是和之前一样，要找一个移花接木的类，一直向上寻找，直到找到 readObject 这样就能形成一个完整的反序列化链，说白了就是找调用了 transform（不一定是 InvokerTransformer 中的 transform，也可以是不同类中的同名的方法）这个方法的类。</strong></p><p><strong>然后再找对应的这个方法在哪被调用了，最后一直找到 readObject。</strong></p><p>首先我们寻找 transform 方法，发现 TransformedMap 这个类的 checkSetValue 有调用 transform。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153219261.png" alt="image-20220918153219261"></p><p>接着我们看 valueTransformer.transform (value) 中的 valueTransformer 是什么，能否被我们控制。</p><p>往上寻找，我们发现这个值是由构造函数中创建的，但因为构造函数是 protected，所以我们不能外部直接调用构造函数，但在当前类中肯定是有其他 public 调用了这个构造函数的。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153303845.png" alt="image-20220918153303845"></p><p>寻找在当前类中调用了这个构造函数的方法。找到一个 public 方法，直接就返回构造函数的值。所以我们这里是能够正常控制这个参数的。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153312600.png" alt="image-20220918153312600"></p><p>接着就是 checkSetValue 方法的问题了，checkSetValue 方法也是 protected 的，追踪这个方法，发现在它的父类中有个 public 方法调用了。这个类我们看不太懂什么意思，但看类名应该不难猜想出来，这不就是 Map 的遍历吗？再加上 TransformedMap 的类名和返回值为 Map，所以我们可以猜测这就是 entry 遍历时会执行的类。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153320543.png" alt="image-20220918153320543"></p><p>简单的打个断点测试下，发现居然真的进来了，看来思路没错。并且也是能直接弹 calc 的。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153328282.png" alt="image-20220918153328282"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153331310.png" alt="image-20220918153331310"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153336424.png" alt="image-20220918153336424"></p><h2 id="寻找利用链-2annotationinvocationhandler分析"><a class="anchor" href="#寻找利用链-2annotationinvocationhandler分析">#</a> 寻找利用链 - ②AnnotationInvocationHandler 分析</h2><p>接着我们继续往上找，直到找到 readObject 嘛。搜索 setValue 的用法，刚好找到有个直接就在 readObject 的。</p><p>而且是在原生 jdk 中，直接上手，看看参数是否可控。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153349421.png" alt="image-20220918153349421"></p><p>首先是去追踪 memberValue 这个参数，发现是在构造器中赋值的，但是构造器没有 public 方法，那只能通过反射去获取了。第一个参数是注解，第二个参数是 Map</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153359429.png" alt="image-20220918153359429"></p><p>如图，我们就成功通过反射去获取到实例了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153404619.png" alt="image-20220918153404619"></p><p>接着我们做一个简单的序列化反序列化测试，测试下看看能不能步入到 setValue 中。因为可以看到要进入 setValue 得经过几个 if 判断。打上断点发现，当前情况下我们进不去 setValue，卡在了第一个 if 判断中。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153411937.png" alt="image-20220918153411937"></p><p>我们继续打上更多断点去分析这个 memberType，可以发现，这个 memberType 其实就是我们第一个参数 Override.class。 然后读取 Override 这个注解的 memberTypes，遍历提取里面的一个 name。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153420851.png" alt="image-20220918153420851"></p><p>而这里，Override 的 memberTypes 是空的，我们跟进 Overide 注解看看，发现这个注解是个空注解。因此猜想，如果换个有内容的注解会不会好点呢。于是我们找到 Retention 注解。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153440149.png" alt="image-20220918153440149"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153446446.png" alt="image-20220918153446446"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153449382.png" alt="image-20220918153449382"></p><p>改变参数，把第一个参数换成 Retention.class 再看看，发现，这次 memberTypes 有内容了，但后面 memberType=memberTypes.get (name)。尝试获取这个 name 的时候没获取到，所以还是 null。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153456716.png" alt="image-20220918153456716"></p><p>到这里其实差不多了，这个 name=memberValue.getKey ()，也就是说这是我们传入的 Map 的 key，而 memberTypes 又有一个名为 Value 的数据。因此我们只要让 Map 的 key 为 Value 就行了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153505869.png" alt="image-20220918153505869"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153509523.png" alt="image-20220918153509523"></p><p>到这里我们就分析得差不多了，可以确认的是，我们能够进入 memberValue.setValue（）, 并且 memberValue 也是我们能操控的，接着就剩下 setValue 的参数的问题了，只要这个参数我们可控，那我们这条链就能完美的走下去。当然这个参数我们肯定是能控的，但具体的分析，我们放到后面来讲。</p><h2 id="利用链小结"><a class="anchor" href="#利用链小结">#</a> 利用链小结</h2><p>到这里，我们这条链其实就差不多了，简单的来看就是</p><p>AnnotationInvocationHandler.readObject-&gt;TransformedMap.checkSetValue-&gt;InvokerTransformer.transform-&gt;Runtime.exec</p><h2 id="利用过程的难点"><a class="anchor" href="#利用过程的难点">#</a> 利用过程的难点</h2><p>虽然我们前面分析完了，看起来确实能够利用。但想要实际利用还是有一些疑难的。</p><h3 id="runtime无法序列化的问题"><a class="anchor" href="#runtime无法序列化的问题">#</a> Runtime 无法序列化的问题</h3><p>我们先贴一张用反射来执行 calc 的语句，我们可以看到，即使我们通过反射来获取 runtime 对象，得到的这个对象是无法序列化的。毕竟它的本质还是 runtime 类。而 runtime 类没实现 Serializable 接口。所以我们的 Runtime 对象如何序列化就是首当其冲的第一个难题。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153932604.png" alt="image-20220918153932604"></p><p>为了解决这个问题，我们回顾下 InvokerTransformer 的作用，它就相当于一个装饰器，我们可以预先定义一些装饰动作，只有当执行 transform 方法的时候才会确切的执行这个动作。也就是说我们可以先把生成 runtime 这个实例的所有反射构造好，只有当调用 transform 方法的时候才会创建相应的实例。这样我们就能够正常的达到我们的目的了。</p><p><strong>因为 Runtime 这个类是没实现 Serializable 接口的，所以我们要想执行命令，就得通过 CLASS 这个类，也就是反射类去让代码在运行的过程中动态的生成获取对象，这样我们的对象才能够正常的序列化。</strong></p><p><strong>个人理解：相当于把生成 runtime 实例的工厂给用反射做了出来，这样我们就没有直接生成实例，只有当代码被真正执行的时候，实例才会被工厂给生成出来。</strong></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918153950847.png" alt="image-20220918153950847"></p><p>当我们理解前面 InvokerTransformer 实现反射调用 calc 的逻辑后，我们就需要考虑一个问题了：</p><p><strong>针对上面的 InvokerTransformer，明显是一层套一层的，前面不执行 transform 创建对应的实例，后面就没法执行获取内容。这怎么整呢？</strong></p><p><strong>这里我们引入 transform 的另一个实现类 ChainedTransformer</strong></p><p>下图是 ChainedTransformer 的源码，我们可以看到，它接收一个 transoformers 数组。当调用 ChainedTransformer 它自身的 transform 方法时，会遍历数组 transoformers，然后递归调用它们的 transform 方法把前一个 transoformer 的输出当作下一个 transoformer 的输入。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154031565.png" alt="image-20220918154031565"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154036906.png" alt="image-20220918154036906"></p><p>到这里，Runtime 无法反序列化这个难点就被解决了。</p><h3 id="membervaluesetvalue的参数是否可控的问题"><a class="anchor" href="#membervaluesetvalue的参数是否可控的问题">#</a> memberValue.setValue 的参数是否可控的问题</h3><p>前面我们分析入口类 AnnotationInvocationHandler 时，略过了 memberValue.setValue 参数的分析。</p><p>这里我们就得补上了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154105287.png" alt="image-20220918154105287"></p><p>我们先对代码打上断点分析下。追踪发现，我们成功进入 memberValue.setValue 后，当调用第一个 transformer 的 transform 时，transform 的参数是一个奇怪的值。很显然，我们得想办法让这个参数等于 Runtime.class。但这个值看起来就不是我们能够直接操控的。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154117364.png" alt="image-20220918154117364"></p><p><strong>这肯定不行，要想我们的命令执行能成功，这个 value 就必须得是 Runtime.class。而我们又没法从输入端直接控制这个 value 值。那怎么办呢？</strong></p><p><strong>这里我们再引入 Transformer 接口的另一个实现类 ConstantTransformer。</strong></p><p>这个 ConstantTransformer 类的 transform 方法很简单，就一行，它实现的功能就是不管 transform 的输入是什么，都返回一个装饰器预定义的值。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154134602.png" alt="image-20220918154134602"></p><p>也就是说，我们让这个 Transformer 作为装饰器链的第一条，并且让它的装饰参数为 Runtime.class，这样当执行 ConstantTransformer.transform 时，无论参数是什么，都返回的是 Runtime.class，从而后面的内容就能够被正常执行了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154146612.png" alt="image-20220918154146612"></p><h2 id="整体代码漏洞利用"><a class="anchor" href="#整体代码漏洞利用">#</a> 整体代码漏洞利用</h2><p>至此我们其实已经搞清楚了整个链的思路。我们把代码整合起来，就如下：</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154206172.png" alt="image-20220918154206172"></p><p>大致流程差不多就这样。结合这个图再看，会清晰很多。（自己画的图，意会一哈）</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154215502.png" alt="image-20220918154215502"></p><h1 id="另一条利用链lazymap"><a class="anchor" href="#另一条利用链lazymap">#</a> 另一条利用链 LazyMap</h1><p>CC1 还存在另一条利用链，即：</p><p>AnnotationInvocationHandler.readObject-&gt;AnnotationInvocationHandler.invoke-&gt;LazyMap.get-&gt;InvokerTransformer.transform-&gt;Runtime.exec</p><p>这条链的后部分其实和 TransformedMap 是一样的，但前部分稍有差别。直接走进分析。</p><h2 id="动态代理"><a class="anchor" href="#动态代理">#</a> 动态代理</h2><p>这条链其实用到了动态代理的知识点，因此在分析这条链之前，有必要学下下动态代理是个什么玩意。</p><h3 id="场景模拟"><a class="anchor" href="#场景模拟">#</a> 场景模拟</h3><p>我们用一个场景来解释动态代理的好处。首先呢如果我们有个类，他实现了如下四个方法。一开始的代码只是简单的返回 result。但后面我们要加需求，需要它们输出日志。这该如何操作呢？</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154403566.png" alt="image-20220918154403566"></p><p>OK，针对如上的需求，我们写出的代码如下：</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154413873.png" alt="image-20220918154413873"></p><h3 id="代码缺陷"><a class="anchor" href="#代码缺陷">#</a> 代码缺陷</h3><p>从上面我们可以看到，对于如上需求的代码我们存在如下缺陷：</p><ul><li>对核心业务功能有干扰（把日志功能放到了核心计算功能中），导致程序员开发核心业务功能时分散了精力。</li><li>附加功能（日志功能）分散在各个业务功能方法中，不利于统一维护。</li></ul><h3 id="解决思路"><a class="anchor" href="#解决思路">#</a> 解决思路</h3><p>解决两个问题，核心就是解耦。我们需要把附加功能从业务功能代码中抽取出来。</p><p>也就说说把日志功能从加减乘除的核心方法中抽离出来。</p><h3 id="困难"><a class="anchor" href="#困难">#</a> 困难</h3><p>要抽取的代码在方法内部并且不是连续执行的（日志功能分别在核心功能的前后），靠以前把子类中的重复代码抽取到父类的方法没法解决。所以需要引入新的技术 —— 代理模式。</p><h3 id="代理模式一种思想"><a class="anchor" href="#代理模式一种思想">#</a> 代理模式（一种思想）</h3><p>代理模式是二十三种设计模式中的一种，属于结构型模式。它的作用是通过提供一个代理类，让我们在调用目标方法的时，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来 —— 解耦。</p><p>调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p><p>代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。</p><p><img data-src="C:/Users/momo/AppData/Roaming/Typora/typora-user-images/image-20220918154733932.png" alt="image-20220918154733932"></p><h3 id="静态代理"><a class="anchor" href="#静态代理">#</a> 静态代理</h3><p>PS: 说白了就是再多套一层类。这里通过实现 Calc 接口，把 CalcImpl 类作为属性。通过代理类去操作。</p><p>实际上未解决统一维护的问题，只是把问题转嫁给了代理对象。完全不具备任何灵活性，并且产生了大量的重复代码，日志还是分散管理的。没有统一管理。</p><p>因此提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这个代理类来实现。这就需要动态代理实现了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154827904.png" alt="image-20220918154827904"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154836975.png" alt="image-20220918154836975"></p><h3 id="动态代理jdk动态代理"><a class="anchor" href="#动态代理jdk动态代理">#</a> 动态代理（JDK 动态代理）</h3><p>目标类必须实现某个接口。</p><p>通过 JDK 中的 api 动态（在代码运行中）的为某一个类创建它的代理类，要求必须有接口，最终生成的代理类在 com.sun.proxy 包下，类名为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi><mi>y</mi><mn>1</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">proxy1,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mord">1</span><span class="mpunct">,</span></span></span></span>proxy2….. 因此会对以后我们的代码有影响。<br>这其实就是利用到反射的机制去实现的。因此需要引入反射包。<br>PS：简单的说就是调用 api 动态的生成类似上面的静态代理类。它的接口看起来有点复杂，但其实我们只需要按照格式，按部就班填就差不多了。</p><p>如下代码我们就是预定义了 CalcImpl 这个类的代理类该怎么实现，怎么做。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154924580.png" alt="image-20220918154924580"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918154930156.png" alt="image-20220918154930156"></p><p>这里再强调下，想要使用动态代理的一些问题和动态代理的一些特性：</p><p>①目标类必须是实现了某个接口才能创建代理对象。</p><p>②动态代理的对象必定会调用 InvocationHandler 这个接口的某个实现类的 invoke 方法。<strong>也就是说，如果如果某个类实现了 InvocationHandler 这个接口，如果此时用上动态代理，那么我们就必定能执行它的 invoke 方法，从而改写我们的利用链</strong>。（从上面的代码也可以看出，我们无论执行 add 还是 sub 都会调用到 InvocationHandler 中的 invoke 方法）</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918155122580.png" alt="image-20220918155122580"></p><h2 id="lazymap分析"><a class="anchor" href="#lazymap分析">#</a> LazyMap 分析</h2><p>首先，还是从 transform 这个方法走起。查找它的用法，发现在 LazyMap 这个类中的 get 方法中有用到，接着我们分析我们能否控制它的参数。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918155153505.png" alt="image-20220918155153505"></p><p>分析发现，其实和 TransformedMap 差不多的，直接尝试一下能否直接调用成功执行 calc。可以看到，这条链是能够正常利用的。接着我们就得往上寻找更多调用，直到找到 readObject 了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918155201579.png" alt="image-20220918155201579"></p><h2 id="annotationinvocationhandler中的invoke分析"><a class="anchor" href="#annotationinvocationhandler中的invoke分析">#</a> AnnotationInvocationHandler 中的 invoke 分析</h2><p>向上寻找调用了 get 方法的类，但这个 get 太常用了，返回结果巨 tm 的多。这里直接看 AnnotationInvocationHandler 这个类。我们先看 readObject，发现也有用到 get 方法的调用。</p><p>但是很可惜的是，前面的对象我们没法控制。因此没法直接利用这个 readObject。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918155223069.png" alt="image-20220918155223069"></p><p>继续看，我们发现当前类的 Invoke 方法也调用了这个 get 方法，并且前面的参数我们是可以控制的。之前已经分析过了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918155230466.png" alt="image-20220918155230466"></p><p>但问题来了，我们要怎么触发这个 invoke 方法呢？此时发现这个方法有个叫 proxy 的参数，是不是就能想到动态代理。然后我们还发现这个类实现了 InvocationHandler 接口。也就是说，我们用上动态代理，把这个类当作动态代理的第三个参数传进去，就必定能执行调用这个类的 Invoke 方法。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918155238026.png" alt="image-20220918155238026"></p><p>到这里，其实就差不多了，我们简单做下测试，看下这条链能不能走完。很显然，我们这个思路是没问题的。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918155245213.png" alt="image-20220918155245213"></p><h2 id="恶意对象的构造"><a class="anchor" href="#恶意对象的构造">#</a> 恶意对象的构造</h2><p>接着就剩最后一步，我们最终怎么和 readObject 联动起来？从前面我们得知，要想动态代理能够执行，就必须得执行代理的对象的任意方法（但不包括 readObject，亲测）。</p><p>那这里我们就想到了再套一层，因为在 AnnotationInvocationHandler 的 readObject 中调用了 memberValues 的很多方法。比如下图，箭头指的地方都是，当这个 memberValues 为代理对象时，都会执行到绑定的 InvocationHandler 的 invoke 方法。</p><p>所以我们就可以把代理对象给封装到 AnnotationInvocationHandler 中，这样，在对这个封装对象进行反序列化的时，就会执行如下函数。从而触发代理对象的 invoke，进入到利用链中。</p><p>PS：有个很奇怪的事，我打断点发现，特么的，打在 invoke 的断点是在 calc 弹出后才步入的。而且离谱的是，如果在 invoke 中打上断点后，我在后面的 InvokerTransformer 这些类打的断点都不生效。没搞懂什么情况？？莫非是动态代理打断点没用？？</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918155327271.png" alt="image-20220918155327271"></p><p>最终我们构造完整的 POC，如下图。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918155418448.png" alt="image-20220918155418448"></p><p>往 exec 里打个断点，发现确实没什么毛病。执行流程也和我们想像中的是一样的。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918155426455.png" alt="image-20220918155426455"></p><h2 id="画个图理清流程"><a class="anchor" href="#画个图理清流程">#</a> 画个图理清流程</h2><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20220918155438329.png" alt="image-20220918155438329"></p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-09-18 15:55:16" itemprop="dateModified" datetime="2022-09-18T15:55:16+08:00">2022-09-18</time> </span><span id="2022/09/16/Java反序列化(4)-CC1/" class="item leancloud_visitors" data-flag-title="Java反序列化(4)-CC1" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>ruyue <i class="ic i-at"><em>@</em></i>如月专注</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2022/09/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(4)-CC1/" title="Java反序列化(4)-CC1">http://example.com/2022/09/16/Java反序列化(4)-CC1/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/09/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(3)-URLDNS%E9%93%BE/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;ruyue-1258558004.cos.ap-guangzhou.myqcloud.com&#x2F;note&#x2F;小夫2.png" title="Java反序列化(3)-URLDNS链"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>Java反序列化(3)-URLDNS链</h3></a></div><div class="item right"><a href="/2022/10/06/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;ruyue-1258558004.cos.ap-guangzhou.myqcloud.com&#x2F;note&#x2F;小夫3.png" title="Java RMI（远程方法调用）漏洞分析"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>Java RMI（远程方法调用）漏洞分析</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#transformermap%E8%BF%99%E6%9D%A1%E9%93%BE%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">TransformerMap 这条链的分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#invokertransformer%E7%B1%BB%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">InvokerTransformer 类分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%88%A9%E7%94%A8%E9%93%BE-1transformermap%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">寻找利用链 - ①TransformerMap 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%88%A9%E7%94%A8%E9%93%BE-2annotationinvocationhandler%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">寻找利用链 - ②AnnotationInvocationHandler 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%93%BE%E5%B0%8F%E7%BB%93"><span class="toc-number">2.4.</span> <span class="toc-text">利用链小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E9%9A%BE%E7%82%B9"><span class="toc-number">2.5.</span> <span class="toc-text">利用过程的难点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#runtime%E6%97%A0%E6%B3%95%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.1.</span> <span class="toc-text">Runtime 无法序列化的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#membervaluesetvalue%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E5%90%A6%E5%8F%AF%E6%8E%A7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.2.</span> <span class="toc-text">memberValue.setValue 的参数是否可控的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">2.6.</span> <span class="toc-text">整体代码漏洞利用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%A6%E4%B8%80%E6%9D%A1%E5%88%A9%E7%94%A8%E9%93%BElazymap"><span class="toc-number">3.</span> <span class="toc-text">另一条利用链 LazyMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">场景模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BC%BA%E9%99%B7"><span class="toc-number">3.1.2.</span> <span class="toc-text">代码缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">3.1.3.</span> <span class="toc-text">解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%B0%E9%9A%BE"><span class="toc-number">3.1.4.</span> <span class="toc-text">困难</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%80%E7%A7%8D%E6%80%9D%E6%83%B3"><span class="toc-number">3.1.5.</span> <span class="toc-text">代理模式（一种思想）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">3.1.6.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">3.1.7.</span> <span class="toc-text">动态代理（JDK 动态代理）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lazymap%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">LazyMap 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#annotationinvocationhandler%E4%B8%AD%E7%9A%84invoke%E5%88%86%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">AnnotationInvocationHandler 中的 invoke 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">3.4.</span> <span class="toc-text">恶意对象的构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%BB%E4%B8%AA%E5%9B%BE%E7%90%86%E6%B8%85%E6%B5%81%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">画个图理清流程</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/07/30/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(1)-%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/" rel="bookmark" title="Java反序列化(1)-反射基础">Java反序列化(1)-反射基础</a></li><li><a href="/2022/08/15/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(2)-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/" rel="bookmark" title="Java反序列化(2)-反序列化基础">Java反序列化(2)-反序列化基础</a></li><li><a href="/2022/09/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(3)-URLDNS%E9%93%BE/" rel="bookmark" title="Java反序列化(3)-URLDNS链">Java反序列化(3)-URLDNS链</a></li><li class="active"><a href="/2022/09/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(4)-CC1/" rel="bookmark" title="Java反序列化(4)-CC1">Java反序列化(4)-CC1</a></li><li><a href="/2022/10/06/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="bookmark" title="Java RMI（远程方法调用）漏洞分析">Java RMI（远程方法调用）漏洞分析</a></li><li><a href="/2022/11/09/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" rel="bookmark" title="Java RMI（远程方法调用）漏洞利用">Java RMI（远程方法调用）漏洞利用</a></li><li><a href="/2022/11/15/Java%E5%86%85%E5%AD%98%E9%A9%AC1-Servlet-api%E5%86%85%E5%AD%98%E9%A9%AC/" rel="bookmark" title="Java内存马1:servlet-api类型内存马">Java内存马1:servlet-api类型内存马</a></li><li><a href="/2022/11/29/Java%E5%86%85%E5%AD%98%E9%A9%AC1.5-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B3%A8%E5%85%A5%E5%86%85%E5%AD%98%E9%A9%AC/" rel="bookmark" title="Java内存马1.5:反序列化注入内存马">Java内存马1.5:反序列化注入内存马</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="ruyue" data-src="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/avatar.jpg"><p class="name" itemprop="name">ruyue</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">37</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1eXVlYXR0ZW50aW9u" title="https:&#x2F;&#x2F;github.com&#x2F;ruyueattention"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/09/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(3)-URLDNS%E9%93%BE/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/06/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" title="分类于 密码学">密码学</a></div><span><a href="/2022/03/29/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-HTTPS%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" title="HTTPS协议分析">HTTPS协议分析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="分类于 漏洞复现">漏洞复现</a></div><span><a href="/2021/07/21/CVE-2021-1675/" title="CVE-2021-1675(Windows Print Spooler权限提升漏洞)">CVE-2021-1675(Windows Print Spooler权限提升漏洞)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Vlunstack/" title="分类于 Vlunstack">Vlunstack</a></div><span><a href="/2020/10/26/Vlunstack1/" title="Vlunsatck1">Vlunsatck1</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/" title="分类于 服务器配置">服务器配置</a></div><span><a href="/2022/04/13/%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%90%AD%E5%BB%BA/" title="透明代理-clash+ubuntu">透明代理-clash+ubuntu</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" title="分类于 密码学">密码学</a></div><span><a href="/2022/03/28/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81RSA%E5%8E%9F%E7%90%86/" title="非对称密码-RSA原理">非对称密码-RSA原理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/" title="分类于 容器安全">容器安全</a></div><span><a href="/2022/02/16/k8s-kunbernetes%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8/" title="k8s-Kubernetes部署应用">k8s-Kubernetes部署应用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Windows%E5%AE%89%E5%85%A8/" title="分类于 Windows安全">Windows安全</a></div><span><a href="/2022/04/27/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8E%E6%9C%AC%E5%9C%B0%E7%BB%84%E7%AD%96%E7%95%A5/" title="本地组策略与域组策略">本地组策略与域组策略</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Windows%E5%AE%89%E5%85%A8/" title="分类于 Windows安全">Windows安全</a></div><span><a href="/2021/12/26/COM%E5%8A%AB%E6%8C%81/" title="COM在权限维持中的应用">COM在权限维持中的应用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/" title="分类于 容器安全">容器安全</a></div><span><a href="/2022/03/17/docker%E7%BD%91%E7%BB%9C/" title="docker网络">docker网络</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" title="分类于 密码学">密码学</a></div><span><a href="/2022/03/28/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-SSL%E8%AF%81%E4%B9%A6/" title="非对称密码-SSL证书">非对称密码-SSL证书</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">ruyue @ 如月专注</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">152k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">2:18</span></div><div class="powered-by"></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/09/16/Java反序列化(4)-CC1/",favicon:{show:"夺去目光的故事",hide:"蒙上双眼的故事"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->