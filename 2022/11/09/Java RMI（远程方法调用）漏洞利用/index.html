<!-- build time:Mon Feb 20 2023 15:22:10 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/favicon.ico"><link rel="mask-icon" href="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/logo.svg" color=""><link rel="manifest" href="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/manifest.json"><meta name="msapplication-config" content="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="如月专注" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="如月专注" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="如月专注" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/2022/11/09/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"><title>Java RMI（远程方法调用）漏洞利用 - Java | 如月专注</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Java RMI（远程方法调用）漏洞利用</h1><div class="meta"><span class="item" title="创建时间：2022-11-09 16:08:21"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-11-09T16:08:21+08:00">2022-11-09</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>8 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">如月专注</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/3.jpg"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/小夫2.png"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/wet.jpg"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/小夫4.png"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/小夫6.png"></li><li class="item" data-background-image="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/36.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/11/09/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/avatar.jpg"><meta itemprop="name" content="ruyue"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="如月专注"></span><div class="body md" itemprop="articleBody"><h1 id="简介"><a class="anchor" href="#简介">#</a> 简介</h1><p><strong>PS：下面的客户端攻击、服务端攻击、注册中心攻击都是讨论 JEP290 未引入之前的情况。实战遇到，先看看 java 版本，大于等于下面版本的直接看绕过就行了，小于的话看具体情况选择。</strong></p><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre>Java <span class="token constant">SE</span> Development Kit <span class="token number">8</span><span class="token punctuation">,</span> Update <span class="token number">121</span> <span class="token punctuation">(</span><span class="token constant">JDK</span> <span class="token number">8</span>u121<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Java <span class="token constant">SE</span> Development Kit <span class="token number">7</span><span class="token punctuation">,</span> Update <span class="token number">131</span> <span class="token punctuation">(</span><span class="token constant">JDK</span> <span class="token number">7</span>u131<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Java <span class="token constant">SE</span> Development Kit <span class="token number">6</span><span class="token punctuation">,</span> Update <span class="token number">141</span> <span class="token punctuation">(</span><span class="token constant">JDK</span> <span class="token number">6</span>u141<span class="token punctuation">)</span></pre></td></tr></table></figure><p>我们前面认识了 RMI，也大致了解了 RMI 中各个角色受到的威胁。</p><p>接着我们就对这些方面的威胁做一次简单的复现，以更好的理解。</p><p>这里我用的 JDK8u65，之所以用这个版本是因为 JDK6u141、JDK7u131、JDK 8u121 加入了 JEP 290 限制，限制了可以反序列化的类。所以在高版本环境下复现是会出问题的。需要做一些绕过，这个我们放在最后面。</p><p><strong>简单的说：在 JEP290 未引入前，我们是可以执行任意 Payload 的，但在着之后，我们只能通过 payload/JRMP 来攻击目标，这就要求对方主机到我们主机是网络畅通的。</strong></p><p><strong>因此如果目标机子低版本情况下（在 JEP290 未引入之前），我们可以执行任意的 Payload。如果在着之后，直接看绕过利用就行了，其他都没用了。</strong></p><p>我们可以根据下图，来决定采取什么攻击方式。</p><p>PS：当然，不建议随便连公网上的 RMI 服务，小心被反打，为什么？往下看就懂了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/006iKNp3ly1gg378mdwp2j31ut18015j.jpg" alt="img"></p><h2 id="参考链接"><a class="anchor" href="#参考链接">#</a> 参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjA0NzQwP2Zyb209dGltZWxpbmUjaDMtOA==">https://www.anquanke.com/post/id/204740?from=timeline#h3-8</span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85NjE1MTA0Ng==">https://zhuanlan.zhihu.com/p/96151046</span></p><p><span class="exturl" data-url="aHR0cDovL2V2ZW50cy5qaWFuc2h1LmlvL3AvN2VmNWZmYTM4ZGZhJUVGJUJDJTg4SkVQMjkwJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg5">http://events.jianshu.io/p/7ef5ffa38dfa（JEP290 详解）</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9wYXBlci5zZWVidWcub3JnLzEwOTEvI3NlcnZlcnJtaS1zZXJ2ZXI=">https://paper.seebug.org/1091/#serverrmi-server</span></p><p>[<span class="exturl" data-url="aHR0cHM6Ly9sYWxhanVuLmdpdGh1Yi5pby8yMDIwLzA2LzIyL1JNSSUyMCVFNSU4RiU4RCVFNSVCQSU4RiVFNSU4OCU5NyVFNSU4QyU5Ni0lRTYlQjclQjElRTUlODUlQTUtJUU0JUI4JThBLw==">https://lalajun.github.io/2020/06/22/RMI 反序列化 - 深入 - 上 /</span>](<span class="exturl" data-url="aHR0cHM6Ly9sYWxhanVuLmdpdGh1Yi5pby8yMDIwLzA2LzIyL1JNSQ==">https://lalajun.github.io/2020/06/22/RMI</span> 反序列化 - 深入 - 上 /) （必看，有上下两篇）</p><h1 id="客户端发起攻击"><a class="anchor" href="#客户端发起攻击">#</a> 客户端发起攻击</h1><h2 id="客户端攻击registry"><a class="anchor" href="#客户端攻击registry">#</a> 客户端攻击 Registry</h2><p><strong>PS: 其实就是通过连接注册中心，使用 bind 绑定一个恶意对象到注册中心上。</strong></p><p>具体漏洞点我们前面也分析过了，这里不在赘述。通常情况下，客户端都是只能从注册中心获取数据的，但唯一的例外就是注册对象（服务）时能从本地绑定对象到注册中心。再结合我们前面所说的，高版本 JDK 下，注册中心和服务端必须在同一台机子。因此不难得出结论，在高版本 JDK 下，想要从客户端攻击注册中心不太可能。（一般来说，如果注册中心和服务端在同一台机子上，我们没必要非要攻击注册中心，攻击服务端不就完事了么）</p><p>我们可以看看 Registry 这个类的接口。可以看到就两个接口是接收对象传参的。那么是不是我们只能攻击必须要是 Remote 类型的 Object 接口呢？即实际上只有 bind、rebind 接口才是可以攻击的？</p><p>但事实是 RMI 注册端没有任何校验，你的 payload 放在 Remote 参数位置可以攻击成功，放在 String 参数位置也可以攻击成功。但如果在 Remote 参数攻击的话，我们的 Payload 就需要是 Remote 类型的。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151038743.png" alt="image-20221109151038743"></p><p>这里演示的是 8u65 环境下的攻击。</p><p>我们在本地创建注册中心，还是之前那套代码，但我给它引入了 commons-collections3.2.1 组件。然后客户端的就需要变一下了，这里用的是 CC1 链（代码就是我之前的代码）。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151050308.png" alt="image-20221109151050308"></p><p>同时，这里让代码在远程 jvm 上运行。可以看到，我们最终成功弹出 Calc，成功从客户端攻击注册中心。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151104544.png" alt="image-20221109151104544"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151119087.png" alt="image-20221109151119087"></p><h2 id="客户端攻击服务端"><a class="anchor" href="#客户端攻击服务端">#</a> 客户端攻击服务端</h2><h3 id="场景一服务端存在一个接收object参数的远程方法"><a class="anchor" href="#场景一服务端存在一个接收object参数的远程方法">#</a> 场景一：服务端存在一个接收 Object 参数的远程方法</h3><p><strong>PS: 其实就是通过调用远程对象，传一个恶意对象到服务端上。如果服务器上存在一些危险方法，可以对危险方法进行探测：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05pY2tzdGFEQi9CYVJNSWU=">https://github.com/NickstaDB/BaRMIe</span></strong></p><p>虽然我们前面分析了很多，明确知道了服务端是会反序列化客户端传来的数据的，但是实际上不是说随便传什么程序都会走到反序列化代码那边的。在之前是存在很多校验及排错语句的。比如说我们客户端在获取到服务端的某个对象后， 不可能说你能调用它没有的方法对吧。</p><p>这里我们本地实现了 User 接口，然后把 setUser 方法的第二个参数改成了 Object 类型，而服务端上 setUser 的参数是 String 类型。此时如果我们去调用，就会报错，因为服务端是先去寻找你要执行的方法然后才去反序列化数据的。而你这个方法在服务端是找不到的，所以就抛出错误。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151226060.png" alt="image-20221109151226060"></p><p>也就是说客户端想要攻击服务端就得有个前提：服务端存在一个接收 Object 参数的远程方法。</p><p>这里我们再到把服务段的 setUser 的第二个参数改成 Object 类型，此时我们就能成功触发 readObject，从而执行命令。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151239855.png" alt="image-20221109151239855"></p><h3 id="场景二绕过object类型参数场景一的利用面扩充重要"><a class="anchor" href="#场景二绕过object类型参数场景一的利用面扩充重要">#</a> 场景二：绕过 Object 类型参数（场景一的利用面扩充！！重要！！）</h3><p>在看文章的时候很多文章提到了即使远程方法不存在 Object 类型的参数也可以打。但大多讲得很模糊，完全没搞懂什么意思。直到我看到这篇文章才大彻大悟。</p><p>[<span class="exturl" data-url="aHR0cHM6Ly9sYWxhanVuLmdpdGh1Yi5pby8yMDIwLzA2LzIyL1JNSSUyMCVFNSU4RiU4RCVFNSVCQSU4RiVFNSU4OCU5NyVFNSU4QyU5Ni0lRTYlQjclQjElRTUlODUlQTUtJUU0JUI4JThBLyMlRTUlODglQTklRTclOTQlQThPYmplY3QlRTclQjElQkIlRTUlOUUlOEIlRTUlOEYlODIlRTYlOTUlQjA=">https://lalajun.github.io/2020/06/22/RMI 反序列化 - 深入 - 上 /# 利用 Object 类型参数</span>](<span class="exturl" data-url="aHR0cHM6Ly9sYWxhanVuLmdpdGh1Yi5pby8yMDIwLzA2LzIyL1JNSQ==">https://lalajun.github.io/2020/06/22/RMI</span> 反序列化 - 深入 - 上 /# 利用 Object 类型参数)</p><p>我们前面分析的时，如果我们客户端不管服务段接收的参数类型，强行传个 Object 过去，就会诱发一个名为 method not supported 的错误。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151325172.png" alt="image-20221109151325172"></p><p>起初我以为服务端是在接收到对象后，但后面想明白了，没序列化前就是个 String，怎么可能能够计算呢，所以必是在客户端进行计算后，跟着序列化数据传过去的。相关代码在 sun/rmi/server/UnicastServerRef 类的 dispatch 方法。</p><p>这个 method 抛出的错误很明显，就是客户端传过来的 methodhash 和服务段本地的不一致。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151338064.png" alt="image-20221109151338064"></p><p>而如果我们人为的修改这个 hash 使其通过一致性检查后，就会进入到 unmarshalValue 这个方法中，跟进看看。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151349936.png" alt="image-20221109151349936"></p><p>到这里上面的流程主要就以下步骤：</p><p>1. 根据传输过来的 Method hash，判断本地提供的 RMI 服务类的方法是否有这个 Method hash</p><p>2. 根据 Method hash 取到 Method 类，遍历入参，从输入流按顺序反序列化入参</p><p>3. 当服务端设定的 RMI 方法的入参不是基础数据类型时，执行 in.readObject 就会触发我们的 payload</p><p>通过上述流程，我们不难发现，如果绕过了 method hash 检查，并且服务端这个方法的入参类型不是基础类型的话，我们就能通畅的进行反序列化恶意对象。</p><p><strong>而有个很关键的点就是 String 它不是基础类型。换句话说，如果服务段上这个 method 方法它的入参类型是 String，我们强行给它传个 Object，它也是能够反序列化成功的（前提是绕过 MethodHash 检查）。</strong></p><p><strong>那么：RMI 服务端需要起一个具有 Object 参数的 RMI 方法 的利用条件限制 就扩展到了 RMI 服务端只需要起一个具有不属于基础数据类型参数的 RMI 方法（比如 String 啥的）</strong></p><p>攻击原理核心在于替换原本不是 Object 类型的参数变为 Object 类型。之前我们修改 String 接口变为 Object，是可以做到修改参数类型，但是那样还会修改 method hash。所以这里只能修改底层代码，去替换原本的参数为我们想要的 payload。</p><p>所以就有以下思路:</p><ul><li>直接修改 rmi 底层源码 (将 java.rmi 包的代码复制到新的包中，在其中进行修改)</li><li>在运行时，添加调试器 hook 客户端，在序列化对象之前替换对象</li><li>在客户端使用 Javassist 工具更改字节码</li><li>使用代理，来替换已经序列化的对象中的参数信息</li></ul><h4 id="remoteobjectinvocationhandler的重打包"><a class="anchor" href="#remoteobjectinvocationhandler的重打包">#</a> RemoteObjectInvocationHandler 的重打包</h4><p><strong>下面我们是通过 javaagent hook 住 java.rmi.server.RemoteObjectInvocationHandler 类的 InvokeRemoteMethod 方法的第三个参数把非 Object 的改为 Object。</strong></p><p>这里用如下项目：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FmYW50MS9SZW1vdGVPYmplY3RJbnZvY2F0aW9uSGFuZGxlcg==">https://github.com/Afant1/RemoteObjectInvocationHandler</span></p><p>PS：这里它原本的 payload 是 URLDNS，我自己给它加了 CC1，改起来也不难，就是把自己的 Gadge 库给引入进去。然后按照它原本的格式输出一个恶意对象就完事了。如果不想折腾，就玩玩作者的 URLDNS 也是没毛病的。但我觉得我们虽然不会写工具，但起码能做到改工具把，不然真正让你去打站，总不能就只打个 URLDNS 就够了是把。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151446604.png" alt="image-20221109151446604"></p><p>如果和我一样加了自己的本地 lib 的话，pom 打包配置请参考 https://blog.csdn.net/gaopu12345/article/details/78596830</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151457147.png" alt="image-20221109151457147"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151500893.png" alt="image-20221109151500893"></p><h4 id="攻击利用"><a class="anchor" href="#攻击利用">#</a> 攻击利用</h4><p>最后打包成 jar 包后就可以开始我们的攻击了。这里我们的客户端只需要保证和服务段一样的接口，然后传入正常的数据过去就行。当挂上这个 agent 后，String 类型的参数就会被我们的 payload 给替换掉。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151618094.png" alt="image-20221109151618094"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151625435.png" alt="image-20221109151625435"></p><h3 id="场景三远程加载对象版本要比较低利用苛刻以下我没复现成功"><a class="anchor" href="#场景三远程加载对象版本要比较低利用苛刻以下我没复现成功">#</a> 场景三：远程加载对象（版本要比较低，利用苛刻，以下我没复现成功）</h3><p>其实这种情况下也是想办法让服务段存在一个有 Object 参数的方法来打的。</p><p>具体怎么实现呢，这里先介绍下 codebase</p><p>PS：大致原理就是客户端指定一个 URL，当远程对象（服务端）尝试调用一个它不存在的类时，此时会通过 URL 来实例化对象。</p><p><strong>具体实现就是如果远程对象存在接收一个对象参数，再执行这个对象的某个方法（如下图，远程对象存在这样也一个方法）。然后客户端传一个服务端上不存在的对象给远程对象。再加上 codebase 就能实现攻击了。</strong></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151742447.png" alt="image-20221109151742447"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109151746779.png" alt="image-20221109151746779"></p><p><strong>这里客户端传个了 EvilClass 对象给 Server 端，Server 找不到这么一个类，就会去 Client 指定的 codebase 地址去查找这个类，并执行其中的内容。也就是说这种情况下，根本用不到什么构造反序列化链，只要让这个类是恶意的就完事了。</strong></p><h4 id="java-rmi的动态加载类codebase"><a class="anchor" href="#java-rmi的动态加载类codebase">#</a> <strong>Java RMI 的动态加载类 codebase</strong></h4><p>java.rmi.server.codebase：java.rmi.server.codebase 属性值表示一个或多个 URL 位置，可以从中下载本地找不到的类，相当于一个代码库。代码库定义为将类加载到虚拟机的源或场所，可以将 CLASSPATH 视为 “本地代码库”，因为它是磁盘上加载本地类的位置的列表。就像 CLASSPATH&quot;本地代码库&quot; 一样，小程序和远程对象使用的代码库可以被视为 &quot;远程代码库&quot;。</p><p>RMI 核心特点之一就是动态类加载，如果当前 JVM 中没有某个类的定义，它可以从远程 URL 去下载这个类的 class，动态加载的 class 文件可以使用 http://、ftp://、file:// 进行托管。这可以动态的扩展远程应用的功能，RMI 注册表上可以动态的加载绑定多个 RMI 应用。对于客户端而言，如果服务端方法的返回值可能是一些子类的对象实例，而客户端并没有这些子类的 class 文件，如果需要客户端正确调用这些子类中被重写的方法，客户端就需要从服务端提供的 java.rmi.server.codebaseURL 去加载类；对于服务端而言，如果客户端传递的方法参数是远程对象接口方法参数类型的子类，那么服务端需要从客户端提供的 java.rmi.server.codebaseURL 去加载对应的类。客户端与服务端两边的 java.rmi.server.codebaseURL 都是互相传递的。无论是客户端还是服务端要远程加载类，都需要满足以下条件：</p><ul><li>由于 Java SecurityManager 的限制，默认是不允许远程加载的，如果需要进行远程加载类，需要安装 RMISecurityManager 并且配置 java.security.policy，这在后面的利用中可以看到。</li><li>属性 java.rmi.server.useCodebaseOnly 的值必需为 false。但是从 JDK 6u45、7u21 开始，java.rmi.server.useCodebaseOnly 的默认值就是 true。当该值为 true 时，将禁用自动加载远程类文件，仅从 CLASSPATH 和当前虚拟机的 java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止虚拟机从其他 Codebase 地址上动态加载类，增加了 RMI ClassLoader 的安全性。</li></ul><p>注：在 JNDI 注入的利用方法中也借助了这种动态加载类的思路。</p><p>如果本地的 ClassPath 中找不到就从 codebase 中加载，那么如果这个 codebase 是可控的，也就意味着会从攻击者的服务器上去拉取对象，如果这个类是恶意类就可能造成 RCE，这也是 JNDI 与 RMI 攻击结合的利用场景。</p><p>调试了半天，换了一亿个版本也没成功，算了 - -，反正鸡肋。</p><p>System.<em>setProperty</em>(<strong>&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</strong>,<strong>&quot;true&quot;</strong>);</p><h3 id="场景四jrmp"><a class="anchor" href="#场景四jrmp">#</a> 场景四：JRMP</h3><p>其实就是下面高版本 JDK 下的绕过，高版本能绕过，低版本自然也行。</p><h1 id="注册端发起攻击"><a class="anchor" href="#注册端发起攻击">#</a> 注册端发起攻击</h1><p>因为客户端和服务端都需要和注册中心进行通信，所以可以通过恶意的注册中心攻击客户端，也可以攻击服务端</p><p>但这两种攻击是一样的，都是他们连接注册中心，注册中心给随便给一个恶意对象就行。而且攻击服务端没什么意义，所以这里只演示攻击客户端。</p><p>具体攻击其实就是直接返回恶意数据就完事了，但这就要求我们去实现一个恶意的注册中心，</p><h2 id="场景一直接用ysoserial来完成即可-所有版本均可反打只要目标有对应的利用链"><a class="anchor" href="#场景一直接用ysoserial来完成即可-所有版本均可反打只要目标有对应的利用链">#</a> 场景一：直接用 ysoserial 来完成即可。（所有版本均可反打，只要目标有对应的利用链）</h2><p>而恶意注册中心这种东西，ysoserial 中刚好就有一个 JRMPListen，直接用它的就行。</p><p>我们只需要运行 ysoserial 里面的 exploit/JRMPListener 类即可。看代码可知，它需要三个参数，第一个是恶意注册中心的监听端口，第二个是用的哪条链，第三个则是需要执行的命令。</p><p>PS：也可以直接命令执行 java -cp .\ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 &quot;calc&quot;</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152249859.png" alt="image-20221109152249859"></p><p>只要客户端本地有存在漏洞的组件，一旦尝试和我们的注册中心进行数据请求就会被反打。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152306330.png" alt="image-20221109152306330"></p><p>我们简单的分析下它的 JRMPListener 源码，从 main 入手，代码也不复杂。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152351589.png" alt="image-20221109152351589"></p><p>然后 run 函数中就是监听，线程等待而已，当有连接，就通过 case 来排除协议类型。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152359255.png" alt="image-20221109152359255"></p><p>最后就是去到 doCall 方法，把 payload 发过去了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152405276.png" alt="image-20221109152405276"></p><p><strong>PS：这个和后面的 JEP290 绕过息息相关。而且我测试时发现，客户端哪怕是最新的 JDK8u341 也深受其害。唯一的要求就是需要目标主动连我们的 RMI 注册中心并执行 bind、list、lookup 之类的操作。</strong><br><strong>但这种情况下我们是不是可以用来反打攻击者，比如我们下文中的 JEP290 绕过就需要攻击者去连接我们的 RMI，再或者前面提到过的 BaRMIe，这个工具它会尝试枚举我们 RMI 的对象，这种情况势必会涉及 lookup 的操作，因此必然会受到我们的攻击。</strong><br><strong>这件事告诉我们不要乱用 RMI 利用工具去攻击网上存在的 RMI，你永远也不知道你连上的 RMI 是不是恶意的。</strong></p><p>这里因为 BaRMle 不含 CC 组件，这里用 URLDNS 来测试。可以看到我们成功反打了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152433106.png" alt="image-20221109152433106"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152435385.png" alt="image-20221109152435385"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152438185.png" alt="image-20221109152438185"></p><p>再或者含 CC 组件的 ysomap，可以看到，我们 kali 开启了一个恶意的 RMI 服务，当使用 ysomap 去打这个 RMI 服务的时候直接反制成功。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109171944432.png" alt="image-20221109171944432"></p><h2 id="场景二标准的注册中心绑定恶意对象利用有一定的限制"><a class="anchor" href="#场景二标准的注册中心绑定恶意对象利用有一定的限制">#</a> 场景二：标准的注册中心绑定恶意对象（利用有一定的限制）</h2><p>PS：这里有个很严重的缺陷就是客户端必须去 lookup 指定恶意对象才行。所以建议还是用 yoser 去生成 JRMPListen 来反打客户端。</p><p>这里其实也很简单，就是直接返回一个 Object 对象给目标。但需要注意的是我们 cc1 生成的恶意对象类型不是 Remote，这种类型没法提供远程服务，所以在这里通过动态代理把它变成了 Remote 远程对象类型。然后才能 bind 到注册中心。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152452208.png" alt="image-20221109152452208"></p><p>客户端直接 lookup 就触发 payload 了。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152501113.png" alt="image-20221109152501113"></p><h1 id="服务端发起攻击"><a class="anchor" href="#服务端发起攻击">#</a> 服务端发起攻击</h1><p>其实这里和前面我们使用标准化的注册中心打客户端是一样的，但不同的是，前面注册中心打客户端时，需要客户端去 lookup 获取远程对象。所以利用起来是更加的苛刻的。（客户端存在和服务端一样的接口，并且客户端调用了服务端的恶意方法）</p><p>这里服务端如果需要打成功是需要客户端再往下去调用远程对象的方法，并且这个方法返回一个恶意对象给客户端才行。</p><p>如下图，恶意服务端上的这个远程对象的 setUser 方法返回了一个恶意对象。当客户端调用这个方法后，就会触发 payload。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152522191.png" alt="image-20221109152522191"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152527180.png" alt="image-20221109152527180"></p><h1 id="高版本jdk下的绕过谨慎有被反打的风险"><a class="anchor" href="#高版本jdk下的绕过谨慎有被反打的风险">#</a> 高版本 JDK 下的绕过（谨慎，有被反打的风险）</h1><p>摆烂人集合！不想分析原理了，头疼。大概原理就是通过 JRMP 来绕过的。说白了就是 JRMPClient 这个 payload 怎么（封装才能）绕过 JEP290 的白名单校验。</p><p>以下 jdk 开始引入 JEP290</p><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre>Java <span class="token constant">SE</span> Development Kit <span class="token number">8</span><span class="token punctuation">,</span> Update <span class="token number">121</span> <span class="token punctuation">(</span><span class="token constant">JDK</span> <span class="token number">8</span>u121<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Java <span class="token constant">SE</span> Development Kit <span class="token number">7</span><span class="token punctuation">,</span> Update <span class="token number">131</span> <span class="token punctuation">(</span><span class="token constant">JDK</span> <span class="token number">7</span>u131<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Java <span class="token constant">SE</span> Development Kit <span class="token number">6</span><span class="token punctuation">,</span> Update <span class="token number">141</span> <span class="token punctuation">(</span><span class="token constant">JDK</span> <span class="token number">6</span>u141<span class="token punctuation">)</span></pre></td></tr></table></figure><p>但需要小心了，你这种利用有可能会被反打，具体前面说过了。</p><p>想分析的跟着大佬学：</p><p>[<span class="exturl" data-url="aHR0cHM6Ly9sYWxhanVuLmdpdGh1Yi5pby8yMDIwLzA2LzIyL1JNSSUyMCVFNSU4RiU4RCVFNSVCQSU4RiVFNSU4OCU5NyVFNSU4QyU5Ni0lRTYlQjclQjElRTUlODUlQTUtJUU0JUI4JThCLyMlRTUlODglQTklRTclOTQlQThKUk1QJUU1JThGJThEJUU1JUJBJThGJUU1JTg4JTk3JUU1JThDJTk2JUU3JUJCJTk1JUU4JUJGJTg3SkVQMjkw">https://lalajun.github.io/2020/06/22/RMI 反序列化 - 深入 - 下 /# 利用 JRMP 反序列化绕过 JEP290</span>](<span class="exturl" data-url="aHR0cHM6Ly9sYWxhanVuLmdpdGh1Yi5pby8yMDIwLzA2LzIyL1JNSQ==">https://lalajun.github.io/2020/06/22/RMI</span> 反序列化 - 深入 - 下 /# 利用 JRMP 反序列化绕过 JEP290)</p><p>直接复现怎么绕过利用，大致总结图如下：</p><p>其中已知 RMI 接口的攻击主要问题就是怎么去识别探测，无需多言。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05pY2tzdGFEQi9CYVJNSWU=">https://github.com/NickstaDB/BaRMIe</span></p><p>着重复现最后那个。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/006iKNp3ly1gg378mdwp2j31ut18015j.jpg" alt="img"></p><h2 id="jrmp服务端打jrmp客户端基础知识"><a class="anchor" href="#jrmp服务端打jrmp客户端基础知识">#</a> JRMP 服务端打 JRMP 客户端（基础知识）</h2><p>这其实就是接下来绕过的核心路径，其实这就是 ysoserial 中的 exploit/JRMPListen 攻击链。</p><p>当客户端主动连上一个恶意的注册中心时，它是不受 JEP290 保护的。并且我测试下，8u341 都能利用。</p><p>具体就是通过 ysoserial 启动一个 exploit/JRMPListen，然后我们的受害者连上去，Listen 就会把恶意对象传个客户端，然后客户端就中招了。其实就是上面的注册中心反打客户端。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152614074.png" alt="image-20221109152614074"></p><p>看到这里是不是大概有思路了。也就是说如果服务器主动连接 exploit/JRMPListen，是不是就必然会被我们漏洞利用攻击了？</p><p><strong>因此我们的难点就变成了怎么让受害服务器去主动连接我们的 exploit/JRMPListen</strong>。<br>这里我们再引入 payload/JRMPClient（见下述 PS），只要目标服务器反序列化这个对象就会主动连接外部的 RMI 注册中心。<br><strong>而我们的问题就变成了怎么让目标反序列化这个对象，在 RMI 的漏洞利用中也就是怎么让这个对象绕过 JEP290 的白名单过滤。</strong></p><p>PS：exploit/JRMPListen 配合上 payload/JRMPClient 可以让目标强行与我们的注册中心进行连接。<br>①攻击者在自己服务器使用 exploit/JRMPListener 开启一个 rmi 监听。<br>②攻击者往存在漏洞的服务器发生 payload/JRMPClient，payload 中已经设置了攻击者服务器 ip 及 JRMPListener 监听的端口，漏洞服务器反序列化该 payload 后，会去连接攻击者开启的 rmi 监听 exploit/JRMPListener。然后 exploit/JRMPListener 就会发送预定的恶意 payload 给连接它的漏洞服务器。</p><p><strong>怎么封装 payload/JRMPClient 以让它绕过 JEP290 白名单我是懒得分析了，直接用大佬封装好的 Payload。</strong><br><strong>那么最后的问题就是怎么把这个对象发送给目标呢？</strong></p><h2 id="通过bind去发送payloadjrmpclient8u141之前"><a class="anchor" href="#通过bind去发送payloadjrmpclient8u141之前">#</a> 通过 Bind 去发送 Payload/JRMPClient（8u141 之前）</h2><p>我们知道 RMI 服务段和注册端需要在同一台机子上，但是 JRMP 的反序列化发生在这个地址校验之前，因此这个限制对我们来说没有作用，因此我们可以直接通过 bind 去把这个对象给发送个注册中心。</p><p>此后，在 8u141 修复中对这个校验提前了，因此通过 bind 去发生 payload 不再可行。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152735802.png" alt="image-20221109152735802"></p><p>其实就是攻击者自己做为服务端，然后把 bind 这个 payload 到注册中心。从而实现反序列化。</p><p>这里我用的 Payload 是 ysoserial 的，已经是帮我们封装好的，能够绕过 JEP290 的了，直接拿过来用就行。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152807936.png" alt="image-20221109152807936"></p><p>接着开启我们的 exploit/JRMPListener，然后将 JRMPClient payload 发过去就成功触发反序列化，让目标连接我们的恶意 JRMPListen，从而实现 JEP290 绕过。</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152819837.png" alt="image-20221109152819837"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152822704.png" alt="image-20221109152822704"></p><h2 id="通过lookup去发送payloadjrmpclient8u231之前"><a class="anchor" href="#通过lookup去发送payloadjrmpclient8u231之前">#</a> 通过 lookup 去发送 Payload/JRMPClient（8u231 之前）</h2><p>由于 8u141 之后修复了服务段和注册中心的地址校验问题，没办法再用 Bind 了，但我们还可以使用 lookup 方法来发送 JRMPClient Payload。</p><p>但在 8U231 之后，Oracle 开始对 JEP290 拦截的白名单进行增强修复，因此我们封装的 JRMPClient 无法通过 JEP290 的拦截了。</p><p>这里问题在于 Lookup 只接收 String 类型，我们需要想办法，让我们的 Lookup 能接收 Object 对象，这里要么实现一个 HOOK 拦截器，要么重写 Lookup。</p><p>这里 ysomap 这个工具就重写了 Lookup，我们只需要拿过来用就完事了。</p><p>ysomap.exploit.rmi.component.Naming#lookup</p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152840172.png" alt="image-20221109152840172"></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152844086.png" alt="image-20221109152844086"></p><h2 id="通过lookup去发送payloadjrmpclient8u241之前"><a class="anchor" href="#通过lookup去发送payloadjrmpclient8u241之前">#</a> 通过 lookup 去发送 Payload/JRMPClient（8u241 之前）</h2><p>8u231 主要修复的是</p><p>sun.rmi.registry.RegistryImpl_Skel#dispatch 报错情况消除 ref</p><p>sun.rmi.transport.DGCImpl_Stub#dirty 提前了黑名单</p><p>也就是说我们的 payload/JRMPClient 需要想办法重新封装以绕过 8u231 的修复。</p><p>这里我们利用 ysomap 中封装好的对象，然后老样子通过 lookup 给服务器传进去即可。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3doMXQzcDFnL3lzb21hcA==">https://github.com/wh1t3p1g/ysomap</span></p><p><img data-src="https://ruyue-1258558004.cos.ap-guangzhou.myqcloud.com/note/image-20221109152900587.png" alt="image-20221109152900587"></p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-02-17 16:09:06" itemprop="dateModified" datetime="2023-02-17T16:09:06+08:00">2023-02-17</time> </span><span id="2022/11/09/Java RMI（远程方法调用）漏洞利用/" class="item leancloud_visitors" data-flag-title="Java RMI（远程方法调用）漏洞利用" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>ruyue <i class="ic i-at"><em>@</em></i>如月专注</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2022/11/09/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="Java RMI（远程方法调用）漏洞利用">http://example.com/2022/11/09/Java RMI（远程方法调用）漏洞利用/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/06/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;ruyue-1258558004.cos.ap-guangzhou.myqcloud.com&#x2F;note&#x2F;小夫2.png" title="Java RMI（远程方法调用）漏洞分析"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>Java RMI（远程方法调用）漏洞分析</h3></a></div><div class="item right"><a href="/2022/11/15/Java%E5%86%85%E5%AD%98%E9%A9%AC1-Servlet-api%E5%86%85%E5%AD%98%E9%A9%AC/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;ruyue-1258558004.cos.ap-guangzhou.myqcloud.com&#x2F;note&#x2F;小夫5.png" title="Java内存马1:servlet-api类型内存马"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>Java内存马1:servlet-api类型内存马</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%B5%B7%E6%94%BB%E5%87%BB"><span class="toc-number">2.</span> <span class="toc-text">客户端发起攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BB%E5%87%BBregistry"><span class="toc-number">2.1.</span> <span class="toc-text">客户端攻击 Registry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BB%E5%87%BB%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">2.2.</span> <span class="toc-text">客户端攻击服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%8E%A5%E6%94%B6object%E5%8F%82%E6%95%B0%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">场景一：服务端存在一个接收 Object 参数的远程方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%E7%BB%95%E8%BF%87object%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%9C%BA%E6%99%AF%E4%B8%80%E7%9A%84%E5%88%A9%E7%94%A8%E9%9D%A2%E6%89%A9%E5%85%85%E9%87%8D%E8%A6%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">场景二：绕过 Object 类型参数（场景一的利用面扩充！！重要！！）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#remoteobjectinvocationhandler%E7%9A%84%E9%87%8D%E6%89%93%E5%8C%85"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">RemoteObjectInvocationHandler 的重打包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%88%A9%E7%94%A8"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">攻击利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%89%E8%BF%9C%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%AF%B9%E8%B1%A1%E7%89%88%E6%9C%AC%E8%A6%81%E6%AF%94%E8%BE%83%E4%BD%8E%E5%88%A9%E7%94%A8%E8%8B%9B%E5%88%BB%E4%BB%A5%E4%B8%8B%E6%88%91%E6%B2%A1%E5%A4%8D%E7%8E%B0%E6%88%90%E5%8A%9F"><span class="toc-number">2.2.3.</span> <span class="toc-text">场景三：远程加载对象（版本要比较低，利用苛刻，以下我没复现成功）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-rmi%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%B1%BBcodebase"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">Java RMI 的动态加载类 codebase</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%9B%9Bjrmp"><span class="toc-number">2.2.4.</span> <span class="toc-text">场景四：JRMP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E7%AB%AF%E5%8F%91%E8%B5%B7%E6%94%BB%E5%87%BB"><span class="toc-number">3.</span> <span class="toc-text">注册端发起攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%E7%9B%B4%E6%8E%A5%E7%94%A8ysoserial%E6%9D%A5%E5%AE%8C%E6%88%90%E5%8D%B3%E5%8F%AF-%E6%89%80%E6%9C%89%E7%89%88%E6%9C%AC%E5%9D%87%E5%8F%AF%E5%8F%8D%E6%89%93%E5%8F%AA%E8%A6%81%E7%9B%AE%E6%A0%87%E6%9C%89%E5%AF%B9%E5%BA%94%E7%9A%84%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-number">3.1.</span> <span class="toc-text">场景一：直接用 ysoserial 来完成即可。（所有版本均可反打，只要目标有对应的利用链）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%E6%A0%87%E5%87%86%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%BB%91%E5%AE%9A%E6%81%B6%E6%84%8F%E5%AF%B9%E8%B1%A1%E5%88%A9%E7%94%A8%E6%9C%89%E4%B8%80%E5%AE%9A%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">场景二：标准的注册中心绑定恶意对象（利用有一定的限制）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E8%B5%B7%E6%94%BB%E5%87%BB"><span class="toc-number">4.</span> <span class="toc-text">服务端发起攻击</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%89%88%E6%9C%ACjdk%E4%B8%8B%E7%9A%84%E7%BB%95%E8%BF%87%E8%B0%A8%E6%85%8E%E6%9C%89%E8%A2%AB%E5%8F%8D%E6%89%93%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="toc-number">5.</span> <span class="toc-text">高版本 JDK 下的绕过（谨慎，有被反打的风险）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jrmp%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%89%93jrmp%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">JRMP 服务端打 JRMP 客户端（基础知识）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87bind%E5%8E%BB%E5%8F%91%E9%80%81payloadjrmpclient8u141%E4%B9%8B%E5%89%8D"><span class="toc-number">5.2.</span> <span class="toc-text">通过 Bind 去发送 Payload&#x2F;JRMPClient（8u141 之前）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87lookup%E5%8E%BB%E5%8F%91%E9%80%81payloadjrmpclient8u231%E4%B9%8B%E5%89%8D"><span class="toc-number">5.3.</span> <span class="toc-text">通过 lookup 去发送 Payload&#x2F;JRMPClient（8u231 之前）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87lookup%E5%8E%BB%E5%8F%91%E9%80%81payloadjrmpclient8u241%E4%B9%8B%E5%89%8D"><span class="toc-number">5.4.</span> <span class="toc-text">通过 lookup 去发送 Payload&#x2F;JRMPClient（8u241 之前）</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/07/30/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(1)-%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/" rel="bookmark" title="Java反序列化(1)-反射基础">Java反序列化(1)-反射基础</a></li><li><a href="/2022/08/15/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(2)-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/" rel="bookmark" title="Java反序列化(2)-反序列化基础">Java反序列化(2)-反序列化基础</a></li><li><a href="/2022/09/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(3)-URLDNS%E9%93%BE/" rel="bookmark" title="Java反序列化(3)-URLDNS链">Java反序列化(3)-URLDNS链</a></li><li><a href="/2022/09/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(4)-CC1/" rel="bookmark" title="Java反序列化(4)-CC1">Java反序列化(4)-CC1</a></li><li><a href="/2022/10/06/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="bookmark" title="Java RMI（远程方法调用）漏洞分析">Java RMI（远程方法调用）漏洞分析</a></li><li class="active"><a href="/2022/11/09/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" rel="bookmark" title="Java RMI（远程方法调用）漏洞利用">Java RMI（远程方法调用）漏洞利用</a></li><li><a href="/2022/11/15/Java%E5%86%85%E5%AD%98%E9%A9%AC1-Servlet-api%E5%86%85%E5%AD%98%E9%A9%AC/" rel="bookmark" title="Java内存马1:servlet-api类型内存马">Java内存马1:servlet-api类型内存马</a></li><li><a href="/2022/11/29/Java%E5%86%85%E5%AD%98%E9%A9%AC1.5-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B3%A8%E5%85%A5%E5%86%85%E5%AD%98%E9%A9%AC/" rel="bookmark" title="Java内存马1.5:反序列化注入内存马">Java内存马1.5:反序列化注入内存马</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="ruyue" data-src="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/images/avatar.jpg"><p class="name" itemprop="name">ruyue</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">38</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1eXVlYXR0ZW50aW9u" title="https:&#x2F;&#x2F;github.com&#x2F;ruyueattention"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/06/Java%20RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/15/Java%E5%86%85%E5%AD%98%E9%A9%AC1-Servlet-api%E5%86%85%E5%AD%98%E9%A9%AC/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Vlunstack/" title="分类于 Vlunstack">Vlunstack</a></div><span><a href="/2021/01/04/Vlunstack2/" title="Vlunsatck2">Vlunsatck2</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Java/" title="分类于 Java">Java</a></div><span><a href="/2022/07/30/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(1)-%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/" title="Java反序列化(1)-反射基础">Java反序列化(1)-反射基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%9E%83%E5%9C%BE%E7%AE%B1/" title="分类于 垃圾箱">垃圾箱</a></div><span><a href="/2021/08/19/%E5%A6%82%E4%BD%95%E8%BD%BB%E6%9D%BE%E7%A0%B4%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%AF%86/" title="如何轻松破解前端加密">如何轻松破解前端加密</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/" title="分类于 容器安全">容器安全</a></div><span><a href="/2022/02/15/k8s-kunbernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="k8s-Kubernetes环境搭建">k8s-Kubernetes环境搭建</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Windows%E5%AE%89%E5%85%A8/" title="分类于 Windows安全">Windows安全</a></div><span><a href="/2022/04/27/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8E%E6%9C%AC%E5%9C%B0%E7%BB%84%E7%AD%96%E7%95%A5/" title="本地组策略与域组策略">本地组策略与域组策略</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Java/" title="分类于 Java">Java</a></div><span><a href="/2022/09/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(4)-CC1/" title="Java反序列化(4)-CC1">Java反序列化(4)-CC1</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/windows%E5%AE%89%E5%85%A8/" title="分类于 windows安全">windows安全</a></div><span><a href="/2022/04/27/kerberos%E8%AE%A4%E8%AF%81/" title="kerberos认证">kerberos认证</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/" title="分类于 容器安全">容器安全</a></div><span><a href="/2022/03/03/k8s-kunbernetes%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="k8s-kunbernetes配置不当漏洞利用">k8s-kunbernetes配置不当漏洞利用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" title="分类于 密码学">密码学</a></div><span><a href="/2022/03/28/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-%E5%85%AC%E7%A7%81%E9%92%A5%E5%88%9B%E5%BB%BA/" title="非对称密码-公私钥的创建">非对称密码-公私钥的创建</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Windows%E5%AE%89%E5%85%A8/" title="分类于 Windows安全">Windows安全</a></div><span><a href="/2022/06/24/%E5%9F%9F%E5%A7%94%E6%B4%BE/" title="域委派的原理与利用">域委派的原理与利用</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">ruyue @ 如月专注</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">157k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">2:23</span></div><div class="powered-by"></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/09/Java RMI（远程方法调用）漏洞利用/",favicon:{show:"夺去目光的故事",hide:"蒙上双眼的故事"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//fastly.jsdelivr.net/gh/ruyueattention/ruyueattention.github.io/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->